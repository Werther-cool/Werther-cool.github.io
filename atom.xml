<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Werther的博客</title>
  <subtitle>233333</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-03T14:13:06.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Werther</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/03/03/mac%20%20%E5%85%A8%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2017/03/03/mac  全键盘控制/</id>
    <published>2017-03-03T14:09:08.000Z</published>
    <updated>2017-03-03T14:13:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h1><h2 id="全键盘控制"><a href="#全键盘控制" class="headerlink" title="全键盘控制"></a>全键盘控制</h2><p>在以下两种状态之间切换：在屏幕上导览所有控件，或仅导览文本框和列表   Control-F7<br>移至下一个控件      Tab<br>移至上一个控件      Shift-Tab<br>选定文本栏时移至下一个控件    Control-Tab<br>将焦点移至上一组控件    Control-Shift-Tab<br>移至列表、标签组或菜单中的相邻项<br>移动滑块和调整器（向上箭头可增大值，向下箭头可减小值）    箭头键<br>移至与文本栏相邻的控件    Control-箭头键<br>选取所选菜单项    空格键<br>点按默认按钮或执行默认操作    Return 或 Enter<br>点按“取消”按钮，或关闭菜单而不选取项目    Esc<br>将焦点移至上一个面板    Control-Shift-F6<br>移到菜单栏中的状态菜单    Control-F8<br>激活前台应用中下一个打开的窗口    Command-重音符 (<code>)
激活前台应用中上一个打开的窗口    Shift-Command-重音符 (</code>)<br>将焦点移至窗口抽屉    Option-Command-重音符 (`</p>
<h2 id="默认"><a href="#默认" class="headerlink" title="默认"></a>默认</h2><table>
<thead>
<tr>
<th>cmd+option+esc</th>
<th>强制退出：选择要强制退出的 app。或者，按住 Command-Shift-Option-Esc 3 秒钟来仅强制最前面的 app 退出。</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmd+o</td>
<td>打开所选项，或打开一个对话框以选择要打开的文件。</td>
</tr>
</tbody>
</table>
<p>Control-K    删除插入点与行或段落末尾处之间的文本。<br>Command-Delete    在包含“删除”或“不存储”按钮的对话框中选择“删除”或“不存储”。<br>Fn–上箭头    向上翻页：向上滚动一页。<br>Fn–下箭头    向下翻页：向下滚动一页。<br>Fn–左箭头    开头：滚动到文稿开头。<br>Fn–右箭头    结尾：滚动到文稿末尾。</p>
<p>Command–上箭头    将插入点移至文稿开头。<br>Command–下箭头    将插入点移至文稿末尾。<br>Command–左箭头    将插入点移至当前行的行首。<br>Command–右箭头    将插入点移至当前行的行尾。<br>Option–左箭头    将插入点移至上一字词的词首。<br>Option–右箭头    将插入点移至下一字词的词尾。</p>
<p>Control-F    向前移动一个字符。<br>Control-B    向后移动一个字符。<br>Control-L    将光标或所选内容置于可见区域中央。<br>Control-P    上移一行。<br>Control-N    下移一行。<br>Control-O    在插入点后插入一行。<br>Control-T    将插入点后面的字符与插入点前面的字符交换。</p>
<p>Command–左花括号 ({)    左对齐。<br>Command–右花括号 (})    右对齐。<br>Shift–Command–竖线 (|)    居中对齐。<br>Option-Command-F    前往搜索栏。<br>Option-Command-T    显示或隐藏应用中的工具栏。<br>Option-Command-C    拷贝样式：将所选项的格式设置拷贝到剪贴板。<br>Option-Command-V    粘贴样式：将拷贝的样式应用到所选项。</p>
<p>##Finder</p>
<p>Command-E    推出所选磁盘或宗卷。</p>
<p>Shift-Command-D    打开“桌面”文件夹。<br>Option-Command-L    打开“下载”文件夹。<br>Shift-Command-O    打开“文稿”文件夹。<br>Shift-Command-G    打开“前往文件夹”窗口。<br>Option-Command-P    隐藏或显示 Finder 窗口中的路径栏。<br>Option-Command-S    隐藏或显示 Finder 窗口中的边栏。<br>Command–斜线 (/)    隐藏或显示 Finder 窗口中的状态栏。<br>Command-J    调出“显示”选项。</p>
<p>Option-Command-D    显示或隐藏 Dock。即使您未打开 Finder，此快捷键通常也有效。</p>
<p>shift-Command-N    新建文件夹。<br>Option-Command-N    新建智能文件夹。</p>
<p>Command-Y    使用“快速查看”预览所选文件。<br>Command-1    以图标方式显示 Finder 窗口中的项目。<br>Command-2    以列表方式显示 Finder 窗口中的项目。<br>Command-3    以分栏方式显示 Finder 窗口中的项目。 </p>
<p>Command–左中括号 ([)    前往上一文件夹。<br>Command–右中括号 (])    前往下一文件夹。<br>Command–上箭头    打开包含当前文件夹的文件夹。<br>Command–Control–上箭头    在新窗口中打开包含当前文件夹的文件夹。<br>Command–下箭头    打开所选项。</p>
<p>Option-连按    在单独窗口中打开文件夹，并关闭当前窗口。<br>Command-连按    在单独标签或窗口中打开文件夹。<br>Command-Delete    将所选项移到废纸篓。<br>Shift-Command-Delete    清倒废纸篓。<br>Option-Shift-Command-Delete    清倒废纸篓（不显示确认对话框）。<br>Command-Y    使用“快速查看”预览文件。<br>Option–调高亮度    打开“显示器”偏好设置。此快捷键可与任一亮度键搭配使用。<br>Option–Mission Control    打开“Mission Control”偏好设置。<br>Option–调高音量    打开“声音”偏好设置。此快捷键可与任一音量键搭配使用。<br>拖移时按 Command 键    将拖移的项目移到其他宗卷或位置。拖移项目时指针会随之变化。<br>拖移时按 Option 键    拷贝拖移的项目。拖移项目时指针会随之变化。<br>拖移时按下 Option-Command    为拖移的项目制作替身。拖移项目时指针会随之变化。<br>Option-点按伸缩三角形    打开所选文件夹内的所有文件夹。此快捷键仅在列表视图中有效。<br>Command-点按窗口标题    查看包含当前文件夹的文件夹。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mac&quot;&gt;&lt;a href=&quot;#mac&quot; class=&quot;headerlink&quot; title=&quot;mac&quot;&gt;&lt;/a&gt;mac&lt;/h1&gt;&lt;h2 id=&quot;全键盘控制&quot;&gt;&lt;a href=&quot;#全键盘控制&quot; class=&quot;headerlink&quot; title=&quot;全键盘控制&quot;&gt;&lt;/a&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React官方教程笔记</title>
    <link href="http://yoursite.com/2017/02/22/React%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/02/22/React官方教程笔记/</id>
    <published>2017-02-22T12:21:04.000Z</published>
    <updated>2017-03-03T08:49:30.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h3>1. 安装</h3><p></p>
<h4>1.1 尝试</h4><br><p>开始之前可以先去<a href="http://codepen.io/gaearon/pen/rrpgNB?editors=0010" target="_blank">codePen</a>尝试一下，也可以下载这份<a href="https://facebook.github.io/react/downloads/single-file-example.html" target="_blank">HTML文件</a>并编辑它来尝试React。</p><br><h4>1.2 <a href="https://github.com/facebookincubator/create-react-app" target="_blank">Creat React App</a>工具</h4><br><p>推荐使用React官方提供的<a href="https://github.com/facebookincubator/create-react-app" target="_blank">Creat React App</a>工具，来快速新建React单页面应用项目。</p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">npm install -g create-react-app</div><div class="line">create-react-app hello-world</div><div class="line">cd hello-world</div><div class="line">npm start</div></pre></td></tr></table></figure><br><br><h4>1.3 推荐工作流</h4><br><p>虽然React可以在没有任何构建工具的情况下进行使用，但在生产环境还是应该使用成套的构建工具来将React用于你的项目。一个现代化的（前端）工作流通常由以下三部分组成：</p><br><ul><br><li><br><strong>包管理器</strong>：比如<a href="https://yarnpkg.com/" target="_blank">Yarn</a>或<a href="https://www.npmjs.com/" target="_blank">Npm</a>，可以让你更方便使用第三方库而不用自己造轮子</li><br><li><br><strong>编译器</strong>：比如<a href="http://babeljs.io/" target="_blank">Babel</a>，能翻译使用了最新语法的代码到浏览器兼容较好的版本</li><br><li><br><strong>打包器</strong> ：比如<a href="https://webpack.github.io/" target="_blank">Webpack</a>或<a href="http://browserify.org/" target="_blank">Browserify</a>，让你能够编写各种风格的模块化的代码，由它们打包和压缩</li><br></ul><br><p>基于以上工作流，你可以通过<a href="https://www.npmjs.com/" target="_blank">Npm</a>或者<a href="https://yarnpkg.com/" target="_blank">Yarn</a>来将React安装到项目，然后使用<a href="http://babeljs.io/" target="_blank">Babel</a>来编译JSX和ES6语法，最终用于生产环境的代码还需要经过<a href="https://webpack.github.io/" target="_blank">Webpack</a>或<a href="http://browserify.org/" target="_blank">Browserify</a>的打包和压缩才能使用。</p><br><h4>1.4 CDN服务</h4>

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">开发环境;</div><div class="line"> src=<span class="string">"https://unpkg.com/react@15/dist/react.js"</span>;</div><div class="line"> src=<span class="string">"https://unpkg.com/react-dom@15/dist/react-dom.js"</span>;</div><div class="line">生产环境</div><div class="line"> src=<span class="string">"https://unpkg.com/react@15/dist/react.min.js"</span></div><div class="line"> src=<span class="string">"https://unpkg.com/react-dom@15/dist/react-dom.min.js"</span></div></pre></td></tr></table></figure>
<p></p><h3>2. Hello World</h3><p></p>
<p>一个最基本的React例子：</p>

<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReactDom.render(</div><div class="line">  &amp;lt;h1&amp;gt;Hello world!&amp;lt;/h1&amp;gt;,</div><div class="line">  document.getElementById('root')</div><div class="line">)</div></pre></td></tr></table></figure>
<p>你可以在<a href="http://codepen.io/gaearon/pen/ZpvBNJ?editors=0010" target="_blank">COdePen</a>上尝试修改这段代码看看效果。</p><br><p>React推荐配合ES6语法使用，但仅需要了解<code>() =&gt; {}</code>、<code>const</code>、<code>let</code>、<code><code>template literals</code></code>和<code>classes</code>这几个特性即可</p><br><h3>3. 初识JSX</h3><br><pre><code class="javascript">const element = &lt;h1&gt;hello world&lt;/h1&gt;</code></pre><br><p>上面这段既不是字符串又不是HTML的代码（其实主要指的是<code>&lt;h1&gt;hello world&lt;/h1&gt;</code>）就是JSX了。官方推荐搭配使用JSX，有别于模板语言，JSX是全功能的JavaScript。JSX 用于创建“React元素”。</p><br><h4>3.1 JSX是表达式</h4><br><p>跟其他JavaScript表达式一样，JSX也是表达式，被React编译后的JSX返回的是普通的JavaScript对象，这意味着你可以类似对待普通JavaScript表达式那样对待一个JSX语句：将它赋值给变量、将他作为函数参数或返回值等等：</p>

<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function getGreating (user) &#123;</div><div class="line">  if (user) &#123;</div><div class="line">    return &amp;lt;h1&amp;gt;hello &#123;formatName(user)&#125;!&amp;lt;/h1&amp;gt;</div><div class="line">  &#125;</div><div class="line">  return &amp;lt;h1&amp;gt;hello world!&amp;lt;/h1&amp;gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>稍微深入一点，Babel会将JSX转换成对<code>react.creatElement()</code>的调用，所以下面两种写法完全等价：</p>

<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// JSX</div><div class="line">const mine = (</div><div class="line">  &amp;lt;h1 className="greeting"&amp;gt;</div><div class="line">    这是我的标题</div><div class="line">  &amp;lt;/h1&amp;gt;</div><div class="line">)</div><div class="line"></div><div class="line">// javaScript</div><div class="line">const yours = react.creatElement(</div><div class="line">  'h1',</div><div class="line">  &#123; className: 'greeting ' &#125;,</div><div class="line">  '这是你的标题'</div><div class="line">)</div></pre></td></tr></table></figure>
<p>然而<code>react.createElement()</code>返回的结果是类似下面这样的一个对象：</p>

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = &#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">'h1'</span>,</div><div class="line">  <span class="attr">props</span>: &#123;</div><div class="line">    <span class="attr">className</span>: <span class="string">'greeting'</span>,</div><div class="line">    <span class="attr">children</span>: <span class="string">'这是谁的标题'</span></div><div class="line">  &#125;</div><div class="line"> <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就不难理解JSX的用法了——像一个javaScript表达式那样去使用。</p><br><h4>3.2 在JSX中嵌入JavaScript表达式</h4><br><p>使用花括号<code>{}</code>，可以在JSX中嵌入任意JavaScript表达式：</p>

<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const element = (</div><div class="line">  &amp;lt;h1&amp;gt;</div><div class="line">    Hello, &#123;formatName(user)&#125;!</div><div class="line">  &amp;lt;/h1&amp;gt;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>为了提升可读性可以对JSX使用缩进和换行，但是为了避免JavaScript自动添加分号的机制给我们带来麻烦，应该在换行的JSX外面添加一对小括号。</p><br><blockquote><p>在JSX的元素中插入用户输入的内容是安全的，React默认会对元素内的文本进行转义以防止XSS攻击。</p></blockquote><br><h4>3.3 在JSX中声明属性</h4><br><p>就像在HTML中声明元素属性，可以在“React元素”上直接声明某个属性。当希望属性值是变量或引用时，则就像在在JSX中嵌入JavaScript表达式，使用花括号<code>{}</code>来插入“React元素”的值。</p><br><pre><code class="javascript">// 简单属性值<br>const element = &lt;div tabIndex=”0”&gt;&lt;/div&gt;;<br>// 属性值为变量或引用<br>const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;</code></pre><br><blockquote><p>需要注意的是，JSX中元素的属性名统一使用驼峰写法（camelCase），并且在React的内置元素上，诸如<code>class</code>、<code>for</code>等属性还需要换成<code>className</code>和<code>htmlFor</code>来使用（自定义元素可以正常使用）。</p></blockquote><br><h4>3.4 在JSX中声明子元素</h4><br><p>如果“React元素”的标签内没有子元素，则可以像在XML中那样使用单标签（包括React内置的HTML元素）。</p>

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = &amp;lt;img src=&#123;user.avatarUrl&#125; /&amp;gt;;</div></pre></td></tr></table></figure>
<p>如果存在子元素，则就像在HTML中那样直接包裹在父元素中即可（注意换行的JSX要加小括号<code>()</code>）：</p>

<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const element = (</div><div class="line">  &amp;lt;div&amp;gt;</div><div class="line">    &amp;lt;h1&amp;gt;Hello!&amp;lt;/h1&amp;gt;</div><div class="line">    &amp;lt;h2&amp;gt;Good to see you here.&amp;lt;/h2&amp;gt;</div><div class="line">  &amp;lt;/div&amp;gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<p></p><h3>4. 渲染元素</h3><p></p>
<p>元素是React应用的最小组成部分。元素描绘了界面。不同于浏览器的DOM元素，React元素是简单对象，创建它们比创建真实的DOM元素要节省太多性能，同时React DOM负责将React元素和真实DOM元素对应起来：</p>

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ele = &amp;lt;h1&amp;gt;Hello World!&amp;lt;<span class="regexp">/h1&amp;gt;</span></div></pre></td></tr></table></figure>
<p><blockquote><p>不能将React元素和React组件搞混，React元素是React组件的组成部分，一个React组件由一个或多个React元素组成。同时也要注意区别DOM元素和React元素，DOM元素指的是HTML标准中规定的具体的某个元素，而React元素实际上是用于告诉React如何渲染页面、渲染时用到哪些DOM元素的一个配置对象，它与DOM元素不是一个概念。</p></blockquote></p>
<p></p><h4>4.1 将React元素渲染到DOM中</h4><p></p>
<p></p><p>先创建一个React元素，然后用<code>ReactDOM.render()</code>将其渲染到DOM的某个元素中（就这么简单）：</p><p></p>
<pre><code class="javascript">const ele = &lt;h1&gt;Hello World!&lt;/h1&gt;
ReactDOM.render(
  ele,
  document.getElementById('root') // 假设页面上有一个id为root的元素
)</code></pre>
<h4>4.2 更新已经渲染的元素</h4>
<p>请记住，React元素是不可变的，一旦创建，你就不能再直接改变它的属性或子元素。假如我们要更新上面已经渲染到<code>id</code>为<code>root</code>的元素中的React元素，那么在没有其他手段的前提下就只能是像电影胶片一样一帧一帧进行刷新：</p>
<pre><code class="javascript">function tick() {
  const element = (
    &lt;div&gt;
      &lt;h1&gt;Hello World!&lt;/h1&gt;
      &lt;p&gt;{new Date().toLocaleTimeString()}&lt;/p&gt;
    &lt;/div&gt;  
  )
  ReactDOM.render(
    ele,
    document.getElementById('root') // 假设页面上有一个id为root的元素
  )
}
setInterval(tick, 1000) // 每秒刷新</code></pre>
<p>当然正常情况下我们不会这么做，但是这里很好的演示了另外一个问题——React在渲染页面时都做了什么？答案是它只渲染了与上次渲染时DOM中不同的部分！React会比较当前渲染与上次渲染时DOM中的不同之处，并只刷新这些地方！</p>
<div class="image-package">
<img src="https://facebook.github.io/react/img/docs/granular-dom-updates.gif" data-original-src="https://facebook.github.io/react/img/docs/granular-dom-updates.gif"><br><div class="image-caption">图片.png</div>
</div>
<h3>5. 组件和<code>props</code>（输入属性）</h3>
<p>组件能让你将UI分割成独立的可复用的片段，这些片段都有各自隔离的作用域，不会互相干扰。你可以将组件理解成类似函数的概念，组件从它的<code>props</code>属性接受参数，然后返回React元素来描述UI。</p>
<h4>5.1 用函数和类（<code>class</code>）定义组件</h4>
<p>最简单的定义组件的方式就是写一个构造函数：</p>
<pre><code class="javascript">function Welcom (props) {
  return &lt;h1&gt;hello, {props.name}&lt;/h1&gt;
}</code></pre>
<p>上面这个<code>Welcom</code>构造函数就是一个合法的React组件，因为它接受一个对象作为参数，然后返回React元素。我们称这样的组件为“函数式”的组件因为它就是一个JavaScript构造函数。当然也可以使用ES6的<code>class</code>特性来定义函数：</p>
<pre><code class="javascript">class Welcom extends React.Component {
  render () {
    return &lt;h1&gt;hello, {this.props.name}&lt;/h1&gt;
  }
}</code></pre>
<p>ES6的<code>class</code>特性其实是ES5的构造函数和对象继承特性的一个语法糖，上面的写法也完全可以转换为ES5的写法。React推荐这种写法存粹是因为写起来方便，可读性也更强。但这种写法的重点是从<code>React.Component</code>继承一些核心的属性，后文还会细说。不过目前简单起见，我们暂时还只是用简单函数来创建组件。</p>
<h4>5.2 渲染组件</h4>
<p>React元素不仅仅可以用于指定需要使用的DOM元素，也可以用于指代自定义的组件：</p>
<pre><code class="javascript">// 指代需要使用的DOM元素
const ele1 = &lt;div /&gt;
// 指代用户自定义的组件
const ele2 = &lt;Welcom name="Sara"&gt;</code></pre>
<p>当React遇到像<code>&lt;Welcom name="Sara"&gt;</code>这种自定义组件时，它会将JSX属性（也就是React元素属性）都放在一个对象中（这个对象就是<code>props</code>）并将其传递给组件的构造函数，构造函数再返回React元素用于渲染。</p>
<h4>5.3 组件的组合</h4>
<p>既然React元素可用于指代自定义组件，那么组件之间就可以相互嵌套使用：</p>
<pre><code class="javascript">function Welcom (props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;
}
function WelcomList () {
  return (
    &lt;div&gt;
      &lt;Welcom name="Sara" /&gt;
      &lt;Welcom name="Lily" /&gt;
      &lt;Welcom name="Tom" /&gt;
    &lt;/div&gt;
  )
}
function App () {
  return &lt;WelcomList /&gt;
}
ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById('root')
)</code></pre>
<h4>5.4 组件的提取</h4>
<p>既然组件可以嵌套组合使用，我们就可以将一个大的组件分割成很多小的组件。React官方鼓励对UI进行切割，分成不同的组件来实现。基本上一组React元素是否要提取成组件，可从以下两点考虑：</p>
<ul>
<li>这组元素在别的地方也要使用</li>
<li>这组元素内部的功能相对复杂</li>
</ul>
<p>这部分其实是组件化的思路，这里不再展开。</p>
<h4>5.5 只读的<code>props</code>
</h4>
<p>类似于“纯函数”的概念（不会改变任何外部的值，包括输入的参数，即与外部完全无耦合），不管是使用构造函数还是类来定义组件，组件都不应该修改它的<code>props</code>，因为这是输入到组件中的参数。在这一点上，React做了严格限定：</p>
<blockquote><p><strong>所有的React组件必须像“纯函数”那样永远不修改自己的<code>props</code>属性</strong></p></blockquote>
<h3>6. <code>state</code>（私有状态）和生命周期</h3>
<p>我们以上文的时钟的例子来理解组件的私有状态和生命周期。</p>
<pre><code class="javascript">function tick() {
  const element = (
    &lt;div&gt;
      &lt;h1&gt;Hello World!&lt;/h1&gt;
      &lt;p&gt;{new Date().toLocaleTimeString()}&lt;/p&gt;
    &lt;/div&gt;  
  )
  ReactDOM.render(
    ele,
    document.getElementById('root') // 假设页面上有一个id为root的元素
  )
}
setInterval(tick, 1000)</code></pre>
<p>首先我们将时钟作为组件提取出来：</p>
<pre><code class="javascript">// 时钟组件
function Clock(props) {
 return (
    &lt;div&gt;
      &lt;h1&gt;Hello World!&lt;/h1&gt;
      &lt;p&gt;{props.date.toLocaleTimeString()}&lt;/p&gt;
    &lt;/div&gt;  
  )
}
// 重新渲染
function tick () {
  ReactDOM.render(
    &lt;Clock date={new Date()} /&gt;,
    document.getElementById('root') // 假设页面上有一个id为root的元素
  )
}
// 每秒刷新
setInterval(tick, 1000)</code></pre>
<p>我们发现对于<code>Clock</code>组件来说，刷新时间的功能其实完全与外部无关，它不涉及到任何外部的变量，完全可以由<code>Clock</code>组件自己来实现而不是让外部传递时间给它。此时<code>Clock</code>组件就需要“私有状态”来实现这个功能了。</p>
<h4>6.1 从<code>React.Component</code>上继承</h4>
<p>到目前为止，我们使用简单的构造函数来创建React组件，不管外部输入属性还是私有状态，都需要我们手动创建和管理，诸如修改私有状态后刷新渲染，外部输入属性为只读这类功能，如果我们没有在构造函数中手动实现则不会存在。</p>
<p>这时我们可以从<code>React.Component</code>这个React内置的构造函数上继承一些有用的方法，这其中就包括对“私有状态”和“生命周期”实现。我们可以使用ES6的<code>class</code>特性来实现这个继承（当然这不是必须的，完全可以使用ES5的构造函数和原型的写法，但那样会繁琐很多，可读性也大大下降）：</p>
<pre><code class="javascript">class Clock extends React.Component {
  render () { // React提供的用于渲染和刷新组件的钩子函数
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.props.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    )
  }
}</code></pre>
<h4>6.2 定义组件私有状态</h4>
<p><code>React.Component</code>提供了<code>props</code>和<code>state</code>来分别访问外部输入属性和内部私有状态。我们可以在时钟组件中通过<code>state</code>访问私有状态，然后在其构造函数中对该私有状态进行初始化，最后将它渲染到页面上：</p>
<pre><code class="javascript">class Clock extends React.Component {
  constructor (props) {
    super(props) // ES6中类的constructor函数可以通过super访问其父类的构造函数
    this.state = { date: new Date() }
  } // 注意，ES6中类的方法之间不需要任何符号
  render () {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    )
  }
}
ReactDOM.render(
  &lt;Clock /&gt;, // 外部不再干涉Clock组件的刷新功能
  document.getElementById('root)
)</code></pre>
<blockquote><p>注意<code>Clock</code>类中的<code>constructor</code>构造函数中，调用了父类的构造函数，这是为了实现完全的继承。使用<code>class</code>特性创建React组件时应当总是执行这一步。</p></blockquote>
<h4>6.3 添加生命周期函数</h4>
<p>从组件被创建到组件被渲染到页面到最终被销毁，React提供了一系列的“生命周期钩子”，用于在组件的不同阶段调用回掉函数。为了让<code>Clock</code>组件能够自己刷新，我们希望在组件被创建后立即添加一个计时器进行每秒刷新，同时在组件被销毁时一并销毁这个计时器，这样我们就需要用到两个生命周期钩子函数：</p>
<ul>
<li>
<code>componentDidMount</code>：组件被渲染到页面后执行</li>
<li>
<code>componentWillUnmount</code>：组件被销毁前执行</li>
</ul>
<pre><code class="javascript">class Clock extends React.Component {
  constructor (props) {
    super(props) // ES6中类的constructor函数可以通过super访问其父类的构造函数
    this.state = { date: new Date() }
  } // 注意，ES6中类的方法之间不需要任何符号
  render () {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    )
  }
  componentDidMount () {
    this.timerID = setInterval(this.tick, 1000)
  }
  componentWillUnmount() {
    clearInterval(this.timerID)
  }
}
ReactDOM.render(
  &lt;Clock /&gt;, // 外部不再干涉Clock组件的刷新功能
  document.getElementById('root)
)</code></pre>
<blockquote><p>注意我们将定时器存储在了组件实例上，而不是<code>state</code>中，请先记住一个原则：任何没有在组件的<code>render()</code>函数中使用的变量，都不应该存放在<code>state</code>中</p></blockquote>
<p>然后再添加<code>tick</code>方法。在这个方法中我们需要改变组件<code>state</code>中的<code>date</code>的值，这时需要用到方法<code>setState()</code>，该方法会通知React现在<code>state</code>已经改变了，而后React会去重新调用组件的<code>Render()</code>方法刷新DOM。这也是为什么会有<strong>任何没有在组件的<code>render()</code>函数中使用的变量，都不应该存放在<code>state</code>中 </strong>一说：</p>
<pre><code class="javascript">class Clock extends React.Component {
  constructor (props) {
    super(props) // ES6中类的constructor函数可以通过super访问其父类的构造函数
    this.state = { date: new Date() }
  } // 注意，ES6中类的方法之间不需要任何符号
  render () {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    )
  }
  componentDidMount () {
    this.timerID = setInterval(this.tick, 1000)
  }
  componentWillUnmount() {
    clearInterval(this.timerID)
  }
  tick () {
    this.setState({ date: new Date() }) // 该方法会触发React调用实例的render方法进行重绘
  }
}
ReactDOM.render(
  &lt;Clock /&gt;, // 外部不再干涉Clock组件的刷新功能
  document.getElementById('root)
)</code></pre>
<h4>6.4 组件生命周期小结</h4>
<ul>
<li>1) 当把组件传递给<code>ReactDOM.render()</code>函数后，React会调用组件的构造函数<code>constructor</code>，进行一些初始化</li>
<li>2) 然后React会去调用<code>Clock</code>组件的<code>render()</code>方法将组件渲染出来</li>
<li>3) 当组件渲染完毕后，React会调用<code>componentDidMount()</code>生命周期钩子函数</li>
<li>4) 当<code>setState()</code>函数被调用时，React会重新调用组件的<code>render()</code>方法进行重绘</li>
<li>5) 当组件被从DOM中移除时，React会调用<code>componentWillUnmount()</code>生命周期钩子函数</li>
</ul>
<h4>6.5 <code>setState</code>注意事项</h4>
<ul>
<li>
<strong>不要直接改变<code>state</code></strong><br>直接对组件<code>state</code>中的属性赋值将不会触发DOM更新，因为React并不知道<code>state</code>被改变了</li>
<li>
<strong><code>state</code>的更新可能是异步的</strong><br>React会一次处理多个对<code>setState</code>的调用以提高性能，所以调用<code>setState()</code>时不应当直接基于另外一些来自<code>state</code>或<code>props</code>中的属性进行计算，很有可能当前计算的值并不是最终的值，当用于计算的另一些值再次变化后，React并不会刷新DOM（因为没有再次调用<code>setState()</code>）。为了修正这点，React提供另一种调用<code>setState()</code>函数的方式：传入一个函数，而不是对象<pre><code class="javascript">// 错误的用法
this.setState({
counter: this.state.counter + this.props.increment
})
// 正确的用法
this.setState((prevState, props) =&gt; ({ // 接受一个表示前次state的参数和一个当前props的参数
counter: prevState.counter + props.increment // 这里实际上是返回了一个对象，是ES6箭头函数的简写
}))</code></pre>
</li>
<li>
<strong><code>setState</code>是对象的合并而不是替换</strong><br><code>setState</code>方法是将传入的参数对象或函数返回的对象与现有的<code>state</code>对象进行合并，非常类似于使用<code>Object.assign(prevState, newState)</code>的效果</li>
</ul>
<h4>6.6 单项数据流</h4>
<p>在React组件的嵌套中，父组件通过<code>props</code>向子组件传递数据，不管传递进来的数据是来自于父组件的<code>props</code>还是<code>state</code>还是别的地方，子组件不知道也不用关心，因为它不能修改通过<code>props</code>传递进来的数据而只能读取它。这样，数据就可以从最外层的父组件一路向内传递下去，但反过来却不行。</p>
<p>这就是传说中的“单项数据流”（"top-down" or "unidirectional" data flow）了：每个组件只能修改本身和其子组件的数据，而不能修改父组件的数据。这样的好处不言而喻，数据和状态的管理会更加方便，但有时候在应用越来越复杂的时候，可能需要多个组件共享某些数据或状态，因此诞生了很多用于管理数据和状态的库，redux就是其中最有名的一个。</p>
<h3>7. 事件</h3>
<h4>7.1 基本用法</h4>
<p>在React中绑定事件跟直接在HTML中绑定事件非常相似，定义一个事件处理函数，并在JSX中绑定它：</p>
<pre><code class="javascript">function Greeting () {
  function sayHi(e) {
    e.preventDefault()
    console.log('Hi!')
  }
 return (
    &lt;a onClick={Greeting}&gt;Click me to say hi!&lt;/a&gt;
 )
}</code></pre>
<p>所有事件绑定属性比如<code>onClick</code>均使用驼峰写法（camelCase），事件绑定属性的值不是字符串而是事件处理函数名称，可以带上<code>()</code>并传参，无参数时可省略<code>()</code>；</p>
<h4>7.2 使用类定义组件时事件处理函数<code>this</code>的指向问题</h4>
<p>使用ES6的<code>class</code>特性定义组件时，通常的做法是将事件处理函数当作该类的方法写在类中。但需要注意的是方法的<code>this</code>指向。</p>
<p>定义在类中的方法的默认的<code>this</code>指向的是当前的类的实例，但事件处理函数因为是绑定到了具体的元素上，就会丢失定义时<code>this</code>的指向。如果你的处理函数中使用了<code>this</code>关键字来指向当前组件实例，那么你需要手动将该方法的<code>this</code>绑定到当前组件实例，有三种方法可以进行绑定：</p>
<p><strong>1）在类的constructor中调用或在JSX中调用<code>Function.prototype.bind()</code>手动绑定</strong></p>
<pre><code class="javascript">class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};
    this.handleClick = this.handleClick.bind(this); // 手动绑定
  }

  handleClick() {
    // console.log(this)
    this.setState(prevState =&gt; ({
      isToggleOn: !prevState.isToggleOn
    }));
  }

  render() {
    return (
      // &lt;button onClick={this.handleClick.bind(this)}&gt; // 在这里绑定也可以
      &lt;button onClick={this.handleClick}&gt;
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      &lt;/button&gt;
    );
  }
}

ReactDOM.render(
  &lt;Toggle /&gt;,
  document.getElementById('content')
);</code></pre>
<p><strong>2）在JSX的事件绑定属性中的事件处理函数外层再套一个箭头函数，在其中返回处理函数调用结果</strong></p>
<pre><code class="javascript">render() {
  return (
    &lt;button onClick={(e) =&gt; this.handleClick(e)}&gt; // 这么绑定也行
      Click me
    &lt;/button&gt;
  );
}</code></pre>
<p><strong>3）Babel提供的一个ES8+的实验性质的写法</strong></p>
<pre><code class="javascript">class LoggingButton extends React.Component {
  handleClick = () =&gt; { // 纯粹的实验性质的写法，需要babel的支持
    console.log('this is:', this);
  }
  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;
        Click me
      &lt;/button&gt;
    );
  }
}</code></pre>
<h4>7.3 事件对象</h4>
<p>React的事件对象是一个完全由React给出的事件对象，该对象对各个浏览器做了兼容，同时保留了标准事件对象的接口，详细信息可以查看React官网的参考。使用时需要关心的是如何在事件处理函数中使用事件对象。</p>
<p>在事件绑定的JSX中，处理函数接受一个名为<code>event</code>的参数来表示事件对象，可以认为<code>event</code>在事件绑定插值中属于React的保留字，如果需要往事件处理函数中传递更多参数，请使用其他标识符。</p>
<p>另外，7.2小节中不同的事件绑定写法也对事件对象的处置略有不同，主要体现在事件绑定JSX中：</p>
<pre><code class="javascript">// 无括号
&lt;button onClick={this.handleClick}&gt;
  Click me
&lt;/button&gt;

// 带括号
&lt;button onClick={this.handleClick(event)}&gt;
  Click me
&lt;/button&gt;

// 调用了bind()
&lt;button onClick={this.handleClick.bind(this, event)}&gt;
  Click me
&lt;/button&gt;</code></pre>
<ul>
<li>当事件绑定插值中的处理函数省略了<code>()</code>时，处理函数默认接受一个表示事件对象的参数，</li>
<li>当事件绑定插值中的处理函数未省略<code>()</code>时，则需要显示地使用保留字<code>event</code>来传入事件对象，未传入则为<code>undefined</code>；<strong>注意，不管有没有在<code>constructor</code>中绑定<code>this</code>，直接在处理函数名后加<code>()</code>会导致页面初始化时该函数被立即执行一次，可能会有意想不到的错误，比如不能调用<code>setState()</code>方法等，所以强烈不建议用这种写法</strong>
</li>
<li>当事件绑定插值中的处理函数调用了<code>bind()</code>时，可以显示地使用保留字<code>event</code>来传入事件对象，否则React会在<code>bind()</code>函数参数序列的末尾默认增加一个表示事件对象的参数</li>
</ul>
<p>最后，在React中不能通过<code>return false</code>来阻止默认事件，而是需要在事件处理函数中显式调用<code>event.preventDefault()</code>。</p>
<h3>8. 条件渲染</h3>
<p>所有的JavaScript条件语句都可以用于React条件渲染，因为本质上JSX就是JavaScript的扩展语言。基于此有三种常用的条件渲染：</p>
<ul>
<li><code>if...else...</code></li>
</ul>
<pre><code class="javascript">function UserGreeting () {
  return &lt;h1&gt;Welcom back!&lt;/h1&gt;
}
function GuestGreeting () {
  return &lt;h1&gt;Please Sign up.&lt;/h1&gt;
}
function App (props) {
  if (!props.isLoggedIn) {
    return &lt;GuestGreeting /&gt;
  }
  return &lt;UserGreeting /&gt;
}

ReactDOM.render(
  &lt;App isLoggedIn={false} /&gt;,
  document.getElementById('root')
)</code></pre>
<ul>
<li>三元运算符</li>
</ul>
<pre><code class="javascript">function App (props) {
  return props.isLoggedIn ? &lt;UserGreeting /&gt; : &lt;GuestGreeting /&gt;
}</code></pre>
<ul>
<li>短路</li>
</ul>
<pre><code class="javascript">function App (props) {
  return props.isLoggedIn &amp;&amp; &lt;UserGreeting /&gt; // props.isLoggedIn为true则显示UserGreeting，否则不显式
}</code></pre>
<p>如果判断逻辑比较复杂，不能用三元或者短路表达式编写，且判断后的结果需要直接用在JSX中（JSX中只能通过<code>{}</code>插入表达式，而不能使用语句），则可使用<code>if...else...</code>语句判断并将结果保存到变量，然后再返回变量或通过<code>{}</code>插值到JSX中：</p>
<pre><code class="javascript">function UserGreeting () {
  return &lt;h1&gt;Welcom back!&lt;/h1&gt;
}
function GuestGreeting () {
  return &lt;h1&gt;Please Sign up.&lt;/h1&gt;
}
function Button (props) {
  return &lt;button onClick={ props.handleToggle }&gt;toggle me&lt;/button&gt;
}

class App extends React.Component {
  constructor (props) {
    super(props)
    this.state = {
      prevState: false
    }
  }
  handleClick () {
    this.setState(prevState =&gt; ({ isLoggedIn: !prevState.isLoggedIn }))
  }
  render () {
    let greeting = this.state.isLoggedIn ? &lt;UserGreeting /&gt; : &lt;GuestGreeting /&gt;
    return (
      &lt;div&gt;
        &lt;div&gt;&lt;Button handleToggle={this.handleClick.bind(this)} /&gt;&lt;/div&gt; // 注意this的重定向
        { greeting }
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(
  &lt;App isLoggedIn={false} /&gt;,
  document.getElementById('root')
)</code></pre>
<p>另外，在组件的<code>render</code>函数中返回假值，会阻止组件渲染，结合条件判断，能够达到隐藏或显示组件的目的。</p>
<h3>9. 列表和<code>key</code>（索引）</h3>
<h4>9.1 渲染列表</h4>
<p>可以像下面这样渲染一个列表：</p>
<pre><code class="javascript">class List extends React.Component {
  constructor (props) {
    super(props)
  }
  render () {
    let list = this.props.number.map(number =&gt; ( // 拼装li
      &lt;li&gt;{number}&lt;/li&gt;
    ))
    return (
      &lt;ul&gt;{list}&lt;/ul&gt;
    )
  }
}

ReactDOM.render(
  &lt;List number={[1, 2, 3, 4, 5]} /&gt;,
  document.getElementById('root')
)</code></pre>
<p>也可以将<code>map()</code>调用通过<code>{}</code>内联到JSX中：</p>
<pre><code class="javascript">class List extends React.Component {
  constructor (props) {
    super(props)
  }
  render () {
    return (
      &lt;ul&gt;{
        this.props.number.map(number =&gt; ( // 内联map()方法
          &lt;li key={number}&gt;{number}&lt;/li&gt;
        ))
      }&lt;/ul&gt;
    )
  }
}</code></pre>
<p>通常会使用数组的<code>map()</code>方法来从数组拼装列表，这与使用JavaScript拼装HTML类似。但上面的代码运行时会出现警告：</p>
<div class="image-package">
<img src="http://upload-images.jianshu.io/upload_images/3094907-2df3975880fcb18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/3094907-2df3975880fcb18d.png?imageMogr2/auto-orient/strip%7CimageView2/2"><br><div class="image-caption">列表渲染报错</div>
</div>
<h4>9.2 <code>key</code>
</h4>
<p>在渲染列表时，React的差异比较算法需要一个在列表范围内的唯一<code>key</code>来提高性能（通常用于获知哪个列表项改变了）。这个唯一的<code>key</code>需要我们手动提供。React官方建议使用列表数据中可用于唯一性标识的字段来作为列表项渲染时的<code>key</code>。如果实在没有，则可使用数组的<code>index</code>勉为其难，性能上可能会打折扣。</p>
<pre><code class="javascript">    let list = this.props.number.map(number =&gt; ( // 拼装li
      &lt;li key={number.toString()}&gt;{number}&lt;/li&gt;
    ))</code></pre>
<p><code>key</code>的使用需要注意一下几点：</p>
<ul>
<li>
<strong>只能在数组内指定<code>key</code></strong>：准确地说，只能在<code>map()</code>的回调函数中使用<code>key</code>
</li>
<li>
<strong><code>key</code>需要在列表范围内保证唯一性</strong>：同一个数组中的<code>key</code>需要保证唯一性，但不同数组中的<code>key</code>无所谓</li>
<li>
<strong><code>key</code>不会作为<code>props</code>传入组件</strong>：可以认为<code>key</code>是React在JSX中的保留字，你不能用它来向组件传递数据而应该改用其他词</li>
</ul>
<h3>10. 表单</h3>
<p>在React中存在一个“受控组件（Controlled Component）”的概念，专门指代被React控制了的表单元素。通过<code>onChange</code>事件的处理函数将表单元素值的变化映射到组件的<code>state</code>中，然后再将组件中的这个映射好的值通过<code>{}</code>在JSX中插值给表单元素的<code>value</code>，（二者缺一不可）这就是一个被React控制了的组件也即“受控组件”了。</p>
<pre><code class="javascript">class Form extends React.Component {
  constructor (props) {
    super(props)
    this.state ={
      inputTextValue: ''
    }
    this.handleInputTextChange = this.handleInputTextChange.bind(this)
  }
  render () {
    return (
      &lt;form&gt;
        &lt;input
          value={this.state.inputTextValue} // 从state中将值绑定到表单元素
          onChange={this.handleInputTextChange}/&gt; 
      &lt;/form&gt;
    )
  }
  handleInputTextChange (e) {
    this.setState({
      inputTextValue: e.target.value // 将表单元素的值的变化映射到state中
    }) 
  }
}

ReactDOM.render(
  &lt;Form /&gt;,
  document.getElementById('root')
)</code></pre>
<p>基本上所有表单元素的使用都跟上例一样，通过<code>value</code>来“控制”元素，让<code>state</code>成为组件唯一的状态保存地。但是有时候在非React项目中使用React或者一些其他原因，我们不希望使用受控组件时，可以选择<a href="https://facebook.github.io/react/docs/uncontrolled-components.html" target="_blank">“非受控组件”</a>技术，这里不再展开。</p>
<h3>11. 共享状态提升</h3>
<p>考虑下面的需求，页面上有两个输入框，用来输入货币数量，一个输入美元，一个输入人民币，还有一行提示文字例如：“我们有1美元，也就是6.9元”；要求两个输入框随意输入一个，另一个输入框会根据汇率自动显示转换后的货币数量，并且下方提示文字也跟随变化。</p>
<p>通常情况下，我们会编写一个用于输入货币数量的组件，然后在页面上放两个这样的组件：</p>
<pre><code class="javascript">const exchangeRate = 6.9339
const currency = {
  '$': '美元',
  '￥': '人民币'
}
class CurrencyInput extends React.Component {
  constructor (props) {
    super(props)
    this.state = {
      value: ''
    }
    this.changeHandler = this.changeHandler.bind(this)
  }
  render () {
    return(
      &lt;div&gt;
        &lt;label&gt;
          {currency[this.props.currency]}：
          &lt;input value={this.state.value} onChange={this.changeHandler}/&gt;
        &lt;/label&gt;
      &lt;/div&gt;
    )
  }
  changeHandler (e) {
    this.setState({
      value: e.target.value
    })
  }
}
class App extends React.Component {
  constructor (props) {
    super(props)
  }
  render () {
    return(
      &lt;div&gt;
        &lt;CurrencyInput currency={'$'}/&gt;
        &lt;CurrencyInput currency={'￥'} /&gt;
        &lt;p&gt;我们有{}美元，也就是{}元&lt;/p&gt;
      &lt;/div&gt;
    )
  }
}

ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById('root')
)</code></pre>
<p>在上面的代码中我们将货币种类通过<code>props</code>传递给输入框组件，分别显示了美元和人名币的输入框。然后在输入框组件内部，我们使用了上一节的“受控组件”技术，将输入框的值交由组件的<code>state</code>控制。但并没有完成需求——两个输入框并不同步，同时组件外部也不知道组件中到底填了什么值所以下面的提示语句也没有更新。</p>
<blockquote><p>很多时候，若干组件需要隐射同一个变化的状态。我们推荐将共享的状态提升至它们最近的共同的祖先上。</p></blockquote>
<p>就像官方推荐的那样，这时我们就需要用到共享状态提升技术：我们要将两个货币输入框组件共享的“数量”状态，提升到它们最近的祖先组件上，也就是<code>App</code>组件上。</p>
<pre><code class="javascript">// ...省略的代码
class CurrencyInput extends React.Component {
  constructor (props) {
    super(props)
    this.handleChange = this.handleChange.bind(this)
  }
  render () {
    return(
      &lt;div&gt;
        &lt;label&gt;
          {CURRENCY[this.props.currency]}：
          &lt;input value={this.props.value} onChange={this.handleChange}/&gt; // 需要传递额外参数的情况下只能再包一层
        &lt;/label&gt;
      &lt;/div&gt;
    )
  }
  handleChange (e) {
    this.props.onValueChange(e.target.value, this.props.currency) // 父级传递进来的回调函数
  }
}

class App extends React.Component {
  constructor (props) {
    super(props)
    this.state = { // 将共享状态存放在祖先元素上
      dollar: '',
      yuan: ''
    }
    this.valueChangeHandler = this.valueChangeHandler.bind(this)
  }
  render () {
    return( // 通过props向下传递共享状态和回调函数，很多情况下子组件共享的状态父级也需要用到
      &lt;div&gt;
        &lt;CurrencyInput value={this.state.dollar} currency={'$'} onValueChange={this.valueChangeHandler}/&gt;
        &lt;CurrencyInput value={this.state.yuan} currency={'￥'} onValueChange={this.valueChangeHandler}/&gt;
        &lt;p&gt;我们有{this.state.dollar}美元，也就是{this.state.yuan}元&lt;/p&gt;
      &lt;/div&gt;
    )
  }
  valueChangeHandler (value, type) {
    this.setState({
      dollar: type === '$' ? value : this.exchange(value, type),
      yuan: type === '￥' ? value : this.exchange(value, type)
    })
  }
  exchange (value, type) {
    return value * (type === '$' ? EXCHANGERATE : 1 / EXCHANGERATE)
  }
}
// ... 省略的代码</code></pre>
<p>其实不管是美元还是人民币，其实背后都只有一个数量，这个数量同时代表了一定数量的美元和一定数量的人民币，所以更好地，我们可以也应该只存放一个状态在父组件上，然后在渲染子组件时计算子组件的状态并传递给他们：</p>
<pre><code class="javascript">// ... 省略的代码
function exchange (value, type) { // 将转换函数放到全局以便子组件可以访问
  return value * (type === '$' ? EXCHANGERATE : 1 / EXCHANGERATE)
}

class CurrencyInput extends React.Component {
 // ... 省略的代码
  render () {
    // 子组件在渲染时自己计算自己的状态
    let currentCurrency = this.props.currentCurrency
    let currency = this.props.currency
    let value = ''
    if (currentCurrency.value !== '' &amp;&amp; !/^\s+$/g.test(currentCurrency.value)) {
      value = currentCurrency.type === currency ?
        currentCurrency.value : 
        exchange(currentCurrency.value, currentCurrency.type)
    }   
    return(
      &lt;div&gt;
        &lt;label&gt;
          {CURRENCY[currency]}：
          &lt;input value={value} onChange={this.handleChange}/&gt;
        &lt;/label&gt;
      &lt;/div&gt;
    )
  }
  // ... 省略的代码
}

class App extends React.Component {
  constructor (props) {
    super(props)
    this.state = {
      currentCurrency: { // 存储一个值，这里具体做法时存储当前改变的值
        value: '',
        type: ''
      } 
    }
    this.valueChangeHandler = this.valueChangeHandler.bind(this)
  }
  render () {
    // 将共享的状态传递给组件，同时父组件需要的状态也自己计算出来
    return(
      &lt;div&gt;
        &lt;CurrencyInput
          currentCurrency={this.state.currentCurrency}
          currency={'$'}
          onValueChange={this.valueChangeHandler}/&gt;
        &lt;CurrencyInput
          currentCurrency={this.state.currentCurrency}
          currency={'￥'}
          onValueChange={this.valueChangeHandler}/&gt;
        &lt;p&gt;我们有{exchange(this.state.currentCurrency.value, '$')}美元，也就是{exchange(this.state.currentCurrency.value, '￥')}元&lt;/p&gt;
      &lt;/div&gt;
    )
  }
  valueChangeHandler (value, type) { // 这里只需要简单映射关系即可，不再需要计算各个组件的具体状态值
    this.setState({
      currentCurrency: { value, type }
    })
  }

}

ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById('root')
)</code></pre>
<p>上面的例子很好地贯彻了React官方反复强调推荐的“单项数据流”模式。虽然多写了一些代码，但是好处是可以减少因为子组件可以自行修改共享状态而引起的一些bug，毕竟我们将共享状态提升到父级组件上以后，所有对共享状态的修改就都集中在父级组件上了。</p>
<p>另外，再次强调一个原则：<strong>任何可以由<code>state</code>或<code>props</code>计算出来的状态，都不应该放在<code>state</code>中</strong>。就像上例那样，应该直接在<code>render()</code>函数中直接计算后使用。</p>
<h3>12. 聚合而不是继承</h3>
<p>React官方推荐使用聚合而不是继承来在组件之间复用代码。通常有两种服用的情况，一种是组件的部分结构或内容不确定，需要由外部传入，这时组件就相当于一个容器；另一种是从更为抽象的组件创建一个较为具体的组件，比如“弹层”和“登陆弹层”。</p>
<h4>12.1 容器</h4>
<p>当组件内有部分内容不确定需要外部传入时，可以使用一个特殊的<code>props</code>属性<code>children</code>来传入。在组件内部访问<code>props.children</code>可以获取使用组件时写在组件开始和结束标签内的内容：</p>
<pre><code class="javascript">function FancyBorder(props) {
  return (
    &lt;div className={'FancyBorder FancyBorder-' + props.color}&gt;
      {props.children}
    &lt;/div&gt;
  );
}

function WelcomeDialog() {
  return (
    &lt;FancyBorder color="blue"&gt;
      &lt;h1 className="Dialog-title"&gt;
        Welcome
      &lt;/h1&gt;
      &lt;p className="Dialog-message"&gt;
        Thank you for visiting our spacecraft!
      &lt;/p&gt;
    &lt;/FancyBorder&gt;
  );
}</code></pre>
<p>当组件有多个部分内容不确定都需要外部传入时，单靠<code>props.children</code>就不能满足需求了。但时不要忘记React组件的<code>props</code>可以接受任意类型的参数，所以其实组件的内容也完全可以直接使用<code>props</code>来传递到组件内部：</p>
<pre><code class="javascript">function SplitPane(props) {
  return (
    &lt;div className="SplitPane"&gt;
      &lt;div className="SplitPane-left"&gt;
        {props.left}
      &lt;/div&gt;
      &lt;div className="SplitPane-right"&gt;
        {props.right}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

function App() { // JSX中使用{}插入另一个JSX，因为JSX也是表达式
  return &lt;SplitPane left={ &lt;Contacts /&gt; } right={ &lt;Chat /&gt; } /&gt;
}</code></pre>
<h4>12.2 具象化</h4>
<p>有时我们希望一个组件是另一个较为抽象的组件的特例（更为具象），官方推荐的做法是将抽象组件包裹在具象组件中，并使用<code>props</code>来配置它：</p>
<pre><code class="javascript">function Dialog(props) {
  return (
    &lt;FancyBorder color="blue"&gt;
      &lt;h1 className="Dialog-title"&gt;
        {props.title}
      &lt;/h1&gt;
      &lt;p className="Dialog-message"&gt;
        {props.message}
      &lt;/p&gt;
    &lt;/FancyBorder&gt;
  );
}

function WelcomeDialog() {
  return (
    &lt;Dialog
      title="Welcome"
      message="Thank you for visiting our spacecraft!" /&gt;
  );
}</code></pre>


]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h3&gt;1. 安装&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;
&lt;h4&gt;1.1 尝试&lt;/h4&gt;&lt;br&gt;&lt;p&gt;开始之前可以先去&lt;a href=&quot;http://codepen.io/gaearon/pen/rrpgNB?editors=0010&quot; target=&quot;_blank&quot;&gt;codeP
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>My Gallery</title>
    <link href="http://yoursite.com/2017/02/20/My-Gallery/"/>
    <id>http://yoursite.com/2017/02/20/My-Gallery/</id>
    <published>2017-02-20T07:57:33.000Z</published>
    <updated>2017-03-03T11:47:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/02/20/My-Gallery/saber.jpg" alt="saber"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/02/20/My-Gallery/saber.jpg&quot; alt=&quot;saber&quot;&gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/02/19/hello-world/"/>
    <id>http://yoursite.com/2017/02/19/hello-world/</id>
    <published>2017-02-19T10:55:15.000Z</published>
    <updated>2017-02-19T10:55:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[Object Oriented Programing]</title>
    <link href="http://yoursite.com/2016/12/22/Object%20Oriented%20Programing/"/>
    <id>http://yoursite.com/2016/12/22/Object Oriented Programing/</id>
    <published>2016-12-22T12:21:04.000Z</published>
    <updated>2017-02-22T12:30:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object-Oriented-Programing"><a href="#Object-Oriented-Programing" class="headerlink" title="Object Oriented Programing"></a>Object Oriented Programing</h1><h2 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h2><ul>
<li>throw “抛出异常”<br>  <code>throw new TypeError(&#39;&quot;this&quot; is null or not defined&#39;);</code></li>
<li><p>“use strict” </p>
<ul>
<li>全部小写,整个字符串是个字符,不能随便添加空格,可以单引号</li>
<li>作用域,在函数内部(顶部), <code>&lt;script&gt;</code> 标签内(相互独立)</li>
</ul>
</li>
<li><p>反括号  var str =  <code>字符串</code> 处理参数过长</p>
</li>
<li><p>== 判断值 === 判断值和类型  若为引用类型, 则判断 地址</p>
</li>
<li><p>with<br>with(对象){对象的作用域,this指向window}省略前缀<br>添加属性,会添加到window上</p>
</li>
<li><p>静态方法: 只能通过 构造函数.方法 来调, this 指向构造函数</p>
</li>
<li><p>动态方法: 添加到原型上的方法,实例调 </p>
</li>
<li><p>str = JSON.stringify(arr)</p>
</li>
<li><p>typeof 都是小写</p>
</li>
<li><p>伪数组 转 真数组<br>  [].push.apply()<br>  ({}).slice.call()  //兼容ie</p>
</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>私有变量和函数</strong></p>
<pre><code>定义在构造函数内部而被this对象的变量,在外部无法访问到的变量和函数
</code></pre><p><strong>公有变量和方法</strong></p>
<pre><code>对外暴露接口,可以通过构造函数对象创建的对象访问的属性和方法
</code></pre><p><strong>代码示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">type,number</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.type = type;   <span class="comment">//公共的属性</span></div><div class="line">        <span class="keyword">this</span>.number = number;</div><div class="line">        <span class="keyword">var</span> city = <span class="string">"广州"</span>;                <span class="comment">//私有变量</span></div><div class="line">        <span class="keyword">var</span> getNumber = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;       <span class="comment">//私有函数</span></div><div class="line">            <span class="keyword">return</span> number;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">var</span> getType = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> type;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">//能够访问私有变量和函数的方法 --- 特权方法</span></div><div class="line">        <span class="keyword">this</span>.getDescription = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(getNumber() + getType() + city);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> car = <span class="keyword">new</span> Car(<span class="string">"汽车"</span>,<span class="string">"201718"</span>);</div><div class="line">    car.getDescription();</div></pre></td></tr></table></figure>
<ul>
<li>prototype (object类型) 是function自带的属性,有一个constructor属性指向该函数,object没有该属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> Object.property中的属性和方法</div><div class="line"></div><div class="line">① constructor 指向原型相关联的构造函数，为Object</div><div class="line">② hasOwnProperty 判断对象中是否拥有某个实例属性(不包括原型链上面的属性)</div><div class="line">    - hasOwnProperty</div><div class="line">    - 对象.hasOwnProperty(&quot;属性&quot;)</div><div class="line">    - 类似in,但是原型对象中的属性不算</div><div class="line">③ isPrototypeOf  校验某个对象是否是指定对象的原型对象(整条原型链)</div><div class="line">④ propertyIsEnumerable 属性是否存在且可枚举(使用for循环可以遍历,即目标属性能否在for循环中显示出来)</div><div class="line">⑤ toString() 返回一个描述目标对象的字符串,对象则返回[object object]</div><div class="line">    Object.prototype.toString.call(被检测的参数如 arr) [object Array]</div><div class="line">   toString(参数) 参数出可以传入一个用于进制数的参数,该参数的默认值为10(主要针对Number类型有效)</div><div class="line">⑥ toLocaleString 同toString,但是会做一些本地化的处理。</div><div class="line">⑦ valueOf() 返回指定对象的原始值</div><div class="line">             如果该对象有 基本数据类型的值,则返回该值,</div><div class="line">             如果没有则返回this本身。</div><div class="line">             Date对象调用该方法会返回一个时间戳。</div></pre></td></tr></table></figure>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul>
<li><p>Object.getPrototypeOf(object) 返回obj的原型  ==&gt; 构造函数的原型属性</p>
</li>
<li><p>break 停止循环 continue 跳过当前 进行下次</p>
</li>
<li><p>delete 关键字</p>
<ul>
<li>删除对象的属性</li>
<li>删除没用var 声明的对象</li>
<li>delete 属性屏蔽 -&gt;访问原型中的属性.就相当于 实例.prototype.属性</li>
</ul>
</li>
<li><p>in关键字 </p>
<ul>
<li>在判断属性是否存在于对象中时,key 是字符串,需要加双引号</li>
<li>in 操作array数组时 操作的是索引值 (1 in arrar) </li>
<li>原型对象上的属性也会被枚举</li>
</ul>
</li>
<li><p>instanceOf </p>
<ul>
<li>对象  instanceOf  构造函数/具体类型   </li>
<li>实例在原型链上就是,对应构造函数的实例 </li>
</ul>
</li>
<li><p>对象.constructor</p>
<ul>
<li>(实例的constructor 来自原型对象的constructor 共同指向 构造函数)</li>
<li>constructor 一定指向构造函数</li>
</ul>
</li>
</ul>
<ul>
<li><p>修改原型中的属性 </p>
<ul>
<li>对象.属性 无法操作原型对象中的属性和方法</li>
<li>对象.属性(对象).属性 可以修改原型对象的属性(对象)的属性</li>
</ul>
</li>
<li><p>null 变量的值不会为null,除非手动设置</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 函数参数是按值传递 </div><div class="line">/*如果形参名称 和 全局变量一样时 就近原则 选择num 为形参*/</div><div class="line">var num = 10;</div><div class="line">function fn(num) &#123;</div><div class="line">    num =5;          // 此时修改的为形参, 而全局变量num 没有被修改</div><div class="line">    console.log(num); //num = 5</div><div class="line">&#125;</div><div class="line">fn(num);</div><div class="line">console.log(num);  // num =10</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    num =<span class="number">5</span>;         <span class="comment">// 此时num 为 全局变量 被修改</span></div><div class="line">    <span class="built_in">console</span>.log(n); <span class="comment">//num = 5</span></div><div class="line">&#125;</div><div class="line">fn(num);</div><div class="line"><span class="built_in">console</span>.log(num);  <span class="comment">// num = 5</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>Fun 和 Obj</p>
<p><img src="/2016/12/22/Object Oriented Programing/oop1.png" alt="oop1-w600"></p>
<p><img src="/2016/12/22/Object Oriented Programing/oop2.png" alt="oop2-w600"></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>实现 o 继承 tmp 对象 (ECMA5方法)<ul>
<li><code>var o = Object.creat(tmp)</code> </li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;name =<span class="string">"名称"</span>&#125;;</div><div class="line"><span class="keyword">var</span> o = &#123;&#125;</div><div class="line"><span class="comment">// 单个实例实现继承</span></div><div class="line">o.__proto__ = obj;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">str.name = <span class="string">"名字"</span>;     <span class="comment">//先创建包装类型,执行完后,对象销毁</span></div><div class="line"><span class="built_in">console</span>.log(str.name)   <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<ol>
<li>属性 通过call传递  B继承了A的属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function B&#123;</div><div class="line">   A.call(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>遍历传递方法 (若直接赋值传递,是引用了相同的内存对象)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (var i in A.prototype)&#123;</div><div class="line">    B.prototype[i]=A.prototype[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>封闭空间</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//1</div><div class="line">(function () &#123;</div><div class="line"></div><div class="line">&#125;)();</div><div class="line">//</div><div class="line">(function () &#123;</div><div class="line"></div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<ul>
<li><p>caller 返回函数调用者</p>
<ul>
<li>场景 主要用于察看函数本身被哪个函数调用</li>
</ul>
</li>
<li><p>callee</p>
<ul>
<li>返回正被执行的 Function 对象，也就是所指定的 Function 对象的正文.</li>
<li>callee是arguments 的一个属性成员，它表示对函数对象本身的引用</li>
<li>arguments.callee.length可以获取实参参数</li>
</ul>
</li>
</ul>
<ul>
<li><p>call </p>
<ul>
<li>供爷法则:<figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- 作用:将 &quot;爷&quot; 中的this指针 改为 &quot;你&quot;</div><div class="line">- 1 将伪数组</div><div class="line">(document.getbytagname()  arguments $(&apos;.class&apos;))</div><div class="line">转换成真数组</div><div class="line">`Array.prototype.slice.call(fackArray);`</div><div class="line">`[].push.apply([],fackArray)`</div><div class="line">真数组转 伪数组</div><div class="line">[].push.apply(fackArray,arr);</div><div class="line">- 2 判断类型:  </div><div class="line">  ```tostring.call(123)     [object number]</div></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>apply</p>
<ul>
<li>和call一样,参数是数组</li>
<li>apply应用 ,保留this指向</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//因为document.getElementById方法的内部实现中需要使用到this,这个this本来期望指向的是document对象</span></div><div class="line"><span class="comment">//当我们以document.getElementById来调用的时候,内部的this指向document对象</span></div><div class="line"><span class="comment">//但是当我们以getId的方式调用的时候,内部的this指向的是window对象(因为我们以普通的方式进行调用)</span></div><div class="line"></div><div class="line"> <span class="comment">//借用apply来修正this</span></div><div class="line"><span class="built_in">document</span>.getElementById = (<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">return</span> func.apply(<span class="built_in">document</span>,<span class="built_in">arguments</span>);</div><div class="line">   &#125;</div><div class="line">&#125;)(<span class="built_in">document</span>.getElementById);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</div><div class="line"><span class="keyword">var</span> div = getId(<span class="string">'demo'</span>);        <span class="comment">//会报错?</span></div><div class="line"><span class="built_in">console</span>.log(div);</div></pre></td></tr></table></figure>
<h3 id="判断类型"><a href="#判断类型" class="headerlink" title="判断类型:"></a>判断类型:</h3><ul>
<li>tostring.call(123)     [object number]</li>
<li>[]是不是Array的一个实例</li>
<li><code>[] instanceof Array</code></li>
<li><code>[].constructor === Array</code></li>
<li>typeof (关键字) 返回值为字符串<br> <code>if(typeof fn == &#39;Function&#39;){}</code></li>
</ul>
<h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1 拼接字符串</span></div><div class="line"><span class="keyword">var</span> arr1  = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">arr1.push.apply(arr1,arr2);</div><div class="line"></div><div class="line"><span class="comment">// 2 求数组中的最大值</span></div><div class="line"><span class="comment">//(Max只能接受离散值) 这里先转换为 Math.max.call(null,3,4,5);</span></div><div class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,arr2);</div></pre></td></tr></table></figure>
<ul>
<li><p>format</p>
</li>
<li><p>拼接 template 模板 绑定集合</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> &lt;!--模板王者演示--&gt;</div><div class="line">&lt;script id="arttemplate" type="text/html"&gt;</div><div class="line">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</div><div class="line">    &lt;ul&gt;</div><div class="line">        &#123;&#123;each films&#125;&#125;</div><div class="line">            &lt;li&gt;</div><div class="line">                &lt;strong&gt;电影名称：&lt;/strong&gt;&#123;&#123;$value.title&#125;&#125;&lt;br&gt;</div><div class="line">                &lt;strong style='color:red'&gt;导演&lt;/strong&gt;&#123;&#123;$value.lead&#125;&#125;</div><div class="line">                &lt;strong style='color:green'&gt;主演:&lt;/strong&gt;&#123;&#123;$value.role&#125;&#125;</div><div class="line">            &lt;/li&gt;</div><div class="line">        &#123;&#123;/each&#125;&#125;</div><div class="line">    &lt;/ul&gt;</div><div class="line">    &lt;/script&gt;</div></pre></td></tr></table></figure>
<p>###字符串:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">接近数组: concat拼接, indexOf , charAt(index)返回特定位置的字符 </div><div class="line">return 'cat'.charAt(1); // returns "a"</div><div class="line">return 'cat'[1]; // returns "a"</div><div class="line">substr (fromIndex, length)  //删除的长度 </div><div class="line">substring(startIndex, endIndex)  //删除截止到</div><div class="line">slice(startIndex, endIndex) </div><div class="line">slice可对数组操作，substring不行</div><div class="line">    </div><div class="line">###字符串 -&gt; 数组 split()分割  *带p的 常用</div><div class="line">按给定字符串分割，返回分割后的多个字符串组成的字符串数组。</div><div class="line">    </div><div class="line">String.prototype.trim()</div><div class="line">从字符串的开始和结尾去除空格。参照部分 ECMAScript 5 标准。</div><div class="line">```  </div><div class="line"></div><div class="line">### 数组:</div><div class="line"></div><div class="line">```Js</div><div class="line">组合记忆 shift unshift pop push</div><div class="line">接近符串: 合并concat ,indexOf()返回索引, </div><div class="line"></div><div class="line">slice(start, end) 数组截取 ,若不传值,则复制一份返回</div><div class="line"></div><div class="line">//创建一个数组的复制</div><div class="line">var shallowCopy = fruits.slice(); </div><div class="line"></div><div class="line">数组 -&gt; 字符串  join(separator) 数组拼接成字符串</div><div class="line"></div><div class="line">###splice  *带p的 常用 </div><div class="line">        splice(start, deleteCount, val1, val2,...) </div><div class="line">        从start位置开始删除,删除deleteCount个,添加val1,val2</div><div class="line"></div><div class="line"></div><div class="line">// ECMA5  </div><div class="line">0.</div><div class="line">var fruits =["apple","banana"]</div><div class="line">fruits.forEach(function (item, index, array) &#123; //遍历</div><div class="line">  console.log(item, index); // Apple 0   Banana 1</div><div class="line">&#125;);</div><div class="line"></div><div class="line">1.</div><div class="line">arr.every(callback[, thisArg]) //不改变原数组,多用来判断</div><div class="line">callback  用来测试每个元素的函数。</div><div class="line">thisArg   执行 callback 时使用的 this 值。</div><div class="line"></div><div class="line">2.</div><div class="line">array.map() 方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。</div><div class="line"></div><div class="line">array.map(callback[, thisArg])</div><div class="line"></div><div class="line">callback 原数组中的元素经过该方法后返回一个新的元素。</div><div class="line">currentValue   callback 的第一个参数，数组中当前被传递的元素。</div><div class="line">index          callback 的第二个参数，数组中当前被传递的元素的索引。</div><div class="line">array          callback 的第三个参数，调用 map 方法的数组。</div><div class="line">thisArg        执行 callback 函数时 this 指向的对象。</div><div class="line"></div><div class="line">常用方法:</div><div class="line">000. 示例</div><div class="line">array.map(function(currentValue, index, array)&#123;</div><div class="line">    </div><div class="line">&#125;)</div><div class="line"></div><div class="line">001. 返回数组各值的平方根</div><div class="line">var numbers = [1, 4, 9];</div><div class="line">var roots = numbers.map(Math.sqrt);</div><div class="line">/* roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9] */</div><div class="line"></div><div class="line">002. 返回数组对应ASCII</div><div class="line">var map = Array.prototype.map</div><div class="line">var a = map.call("Hello World", function(x) &#123; </div><div class="line">  return x.charCodeAt(0); </div><div class="line">&#125;)</div><div class="line"></div><div class="line">3.</div><div class="line">Array.isArray()</div><div class="line">假如一个变量是数组则返回true，否则返回false。</div><div class="line"></div><div class="line">4.</div><div class="line">Array.prototype.toString()</div><div class="line">返回一个由所有数组元素组合而成的字符串。遮蔽了原型链上的 </div><div class="line">Object.prototype.toString() 方法。</div><div class="line"></div><div class="line">5. //待定</div><div class="line">Array.from() </div><div class="line">从类(伪)数组或者迭代对象（iterable object）中创建一个新的数组实例。</div><div class="line"></div><div class="line">Array.from(arrayLike[, mapFn[, thisArg]])</div><div class="line">arrayLike  想要转换成真实数组的类数组对象或可遍历对象。</div><div class="line">mapFn   可选参数，如果指定了该参数，则最后生成的数组会经过该函数的加工处理后再返回。</div><div class="line">thisArg  可选参数，执行 mapFn 函数时 this 的值。</div><div class="line"></div><div class="line">6. 数组 转 字符串</div><div class="line">str = JSON.stringify(array)  </div><div class="line">//将JavaScript值转换为JSON字符串</div><div class="line">// JSON 序列化</div></pre></td></tr></table></figure>
<p>###new 的原理</p>
<ul>
<li>先开辟一个内存空间,先创建一个新的空对象 </li>
<li>把this 指向这个空对象,拷贝函数中的属性和方法</li>
<li>把空对象的 <em>proto</em> 指向 构造函数内部 原型对象 prototype</li>
<li>构造函数执行完成后如果没有 return 把这个新对象返回,(return的是基本数据类型和null,依然返回原对象,因为指针依然指向原对象)</li>
</ul>
<p>实例拷贝原理:<br>实例化的时候,都会将构造函数的属性拷贝一份(包括隐藏属性),同时赋给新值,因为有的构造函数有默认值,就会讲内存空间替换掉</p>
<p>构造函数:<br>return {}. 代替原对象<br>return ‘jacket’ 返回原对象</p>
<p>定义一个构造函数 是不分配内存的<br>只有实例化的时候 才分配内存</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> 例题<span class="number">1</span>:</div><div class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</div><div class="line">b = a;</div><div class="line">a.x = <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(b.x);  <span class="comment">//2</span></div><div class="line">a = &#123;<span class="attr">x</span>:<span class="number">3</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(b.x);  <span class="comment">//2</span></div><div class="line"></div><div class="line">例题<span class="number">2</span>:</div><div class="line"> <span class="keyword">var</span> a = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;;</div><div class="line">    <span class="keyword">var</span> b = a;</div><div class="line">    a.x = a = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;;  </div><div class="line">    <span class="built_in">console</span>.log(a.x);  <span class="comment">// undefined</span></div><div class="line">    <span class="built_in">console</span>.log(b.x);  <span class="comment">// &#123;n:2&#125;</span></div><div class="line">    <span class="built_in">console</span>.log(a);    <span class="comment">// &#123;n:2&#125;</span></div><div class="line">    <span class="built_in">console</span>.log(b)     <span class="comment">// &#123;n:1,x:&#123;n:2&#125;</span></div><div class="line">    </div><div class="line"> <span class="comment">/*</span></div><div class="line">  根据优先级 a.x -&gt; 给原&#123;n:1&#125;对象 添加一个x属性 undefined,</div><div class="line">  根据 赋值运算从右往左, </div><div class="line">  a=&#123;n:2&#125; -&gt; a 指向一个新对象&#123;n:2&#125;,</div><div class="line">  a.x = a -&gt; &#123;n:1&#125;.x 指向 &#123;n:2&#125;</div><div class="line">  */</div></pre></td></tr></table></figure>
<h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj1,obj2</span>) </span>&#123;</div><div class="line">obj2 = obj2 || &#123;&#125;;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj1)</div><div class="line">&#123;</div><div class="line">  <span class="comment">//判断是否是实例属性</span></div><div class="line">  <span class="keyword">if</span>(obj1.hasOwnProperty(i))</div><div class="line">  &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> obj1[i] == <span class="string">'object'</span>)</div><div class="line">      &#123;</div><div class="line">          obj2[i] = <span class="built_in">Array</span>.isArray(obj1[i])?[]:&#123;&#125;;</div><div class="line">          <span class="comment">// 先创建一个空对象,来接收对象</span></div><div class="line">          deepCopy(obj1[i],obj2[i]); <span class="comment">//函数的调用(实参的值赋值给形参)</span></div><div class="line">      &#125;<span class="keyword">else</span></div><div class="line">      &#123;</div><div class="line">          <span class="comment">//基础数据类型</span></div><div class="line">          obj2[i] = obj1[i];</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">deepCopy(obj,obj2);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Object-Oriented-Programing&quot;&gt;&lt;a href=&quot;#Object-Oriented-Programing&quot; class=&quot;headerlink&quot; title=&quot;Object Oriented Programing&quot;&gt;&lt;/a&gt;Object O
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac 脱离鼠标-设置指南</title>
    <link href="http://yoursite.com/2016/01/22/Mac%20%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2016/01/22/Mac 设置指南/</id>
    <published>2016-01-22T06:21:04.000Z</published>
    <updated>2017-03-03T12:25:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac-设置指南"><a href="#Mac-设置指南" class="headerlink" title="Mac 设置指南"></a>Mac 设置指南</h1><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ol>
<li><p><a href="#1-os-x">OS X</a></p>
<ul>
<li><a href="#功能键">功能键</a></li>
<li><a href="#全键盘控制">全键盘控制</a></li>
<li><a href="#spotlight-快捷键">Spotlight 快捷键</a></li>
<li><a href="#输入法快捷键">输入法快捷键</a></li>
<li><a href="#其他快捷键">其他快捷键</a></li>
<li><a href="#设置-trackpad-轻点来点按">设置 Trackpad 轻点来点按</a></li>
<li><a href="#语音">语音</a></li>
<li><a href="#词典">词典</a></li>
<li><a href="#dock-position">Dock Position</a></li>
<li><a href="#更改-caps-lock-键为-control-键">更改 Caps Lock 键为 Control 键</a></li>
<li><a href="#remove-all-dock-iconsocd">Remove all Dock icons[OCD]</a></li>
<li><a href="#重置-launchpad-上图标位置ocd">重置 Launchpad 上图标位置[OCD]</a></li>
<li><a href="#创建大小写敏感的工作区">创建大小写敏感的工作区</a></li>
<li><a href="#keychain-access">Keychain Access</a></li>
</ul>
</li>
<li><p><a href="#2-常用工具">常用工具</a></p>
<ul>
<li><a href="#homebrew">Homebrew</a></li>
<li><a href="#homebrew-cask">Homebrew Cask</a></li>
<li><a href="#iterm2">iTerm2</a></li>
<li><a href="#oh-my-zsh">Oh My Zsh</a></li>
<li><a href="#stow">stow</a></li>
<li><a href="#git-常用别名">Git 常用别名</a></li>
<li><a href="#scroll-reverser">Scroll Reverser</a></li>
<li><a href="#shiftit">ShiftIt</a></li>
<li><a href="#sublime-text-2">Sublime Text 2</a></li>
<li><a href="#macdown">MacDown</a></li>
<li><a href="#z">z</a></li>
<li><a href="#vimium">Vimium</a></li>
<li><a href="#lastpass">LastPass</a></li>
<li><a href="#sourcetree">SourceTree</a></li>
<li><a href="#cheatsheet">CheatSheet</a></li>
<li><a href="#alfred">Alfred</a></li>
</ul>
</li>
<li><p><a href="#3-开发工具">开发工具</a></p>
<ul>
<li><a href="#java">Java</a></li>
<li><a href="#jenv">jEnv</a></li>
<li><a href="#民间使用的-java-版本切换方法">民间使用的 Java 版本切换方法</a></li>
<li><a href="#javaocd">Java[OCD]</a></li>
<li><a href="#intellij-idea">IntelliJ IDEA</a></li>
<li><a href="#rbenv">rbenv</a></li>
<li><a href="#ruby-常用别名">Ruby 常用别名</a></li>
</ul>
</li>
</ol>
<p>一直想写这么一篇文章，把我从同事那里学到的经验分享出来。市面上有很多类似的文章，写得都非常好，让我受益匪浅。不过我还是有一些自己总结出来的经验想要分享。</p>
<p>在工作中，我一般会在 1 到 10 人的团队中，经常会结对编程，即两个人共用一台 Mac 工作，因此也经常会把 Mac 外接一个大显示器、鼠标和键盘。我的常用开发平台有 Java、Ruby、Node.js、Web 等，使用 <a href="https://www.jetbrains.com/" target="_blank" rel="external">JetBrains</a> 的开发工具，比如 IntelliJ IDEA、RubyMine、WebStorm 等。</p>
<p>我深知自己的知识有限，所以写下本文以便和大家切磋交流。同时更有效率的方法和更好的工具也在不断涌现，我也贪心的希望把更好的方法和工具都收集更到到这里，我会不断更新本文，让它尽量不过时。最新内容请访问：<a href="https://github.com/macdao/ocds-guide-to-setting-up-mac" target="_blank" rel="external">https://github.com/macdao/ocds-guide-to-setting-up-mac</a>。欢迎通过 GitHub 的<code>Issues</code>或者直接<code>Pull Requests</code>方式来分享你的经验。期待你的反馈。</p>
<p>我认为“一个高效的 Mac 工作环境”有以下几个特点：</p>
<ul>
<li><p>自动化</p>
<p>举个例子。手动安装一个应用，需要1)打开浏览器，2)搜索应用的名字，3)打开应用网站，4)寻找下载链接和安装方法，5)下载并等待下载完成，6)安装下载文件，7)可能还有后续的安装步骤。而自动化安装一个应用，只需要1)打开终端工具，2)敲入安装命令，3)等待完成这几个步骤。</p>
<p>自动化可以大大简化操作，提高效率。</p>
</li>
<li><p>统一</p>
<p>我经常结对编程，偶尔会遇到快捷键不一样，命令不同等问题。我强烈建议，至少在一个团队中，大家尽量使用相同的快捷键、命令等环境。（我记得有个实践就是这个，可是我一直没找到该实践的名字和出处，求告诉）</p>
</li>
<li><p>够用</p>
<p>够用就好，如果系统本身已经满足了我的需求，我不会再使用第三方工具。</p>
</li>
<li><p>效率</p>
<p>效率，一切都是为了效率。</p>
</li>
</ul>
<p>本文对于第三方应用如何安装和使用只有最简单的介绍，具体还请参考官方网站和相关文档。</p>
<p>有些章节标题标注了[OCD]，意思是这些章节带有我强烈的个人色彩，如果你跟我臭味相投，欢迎借鉴，如果你并不认同，请忽略掉好了。</p>
<p>PS：虽然本文名为“强迫症”，但其实并不是<a href="https://zh.wikipedia.org/wiki/强迫症" target="_blank" rel="external">真正意义上的强迫症</a>，真正意义上的强迫症是一种会对患者的日常生活产生负面影响的疾病。</p>
<h2 id="1-OS-X"><a href="#1-OS-X" class="headerlink" title="1. OS X"></a>1. OS X</h2><p>本节介绍操作系统本身的一些设置。</p>
<h3 id="功能键"><a href="#功能键" class="headerlink" title="功能键"></a>功能键</h3><p>默认情况下，F1-F12 都是特殊功能，比如调节屏幕亮度。而当你需要键入 F1-F12 时（比如在使用 IntelliJ IDEA 的快捷键时），需要同时按住 Fn。这对于开发人员来说是非常不方便的。</p>
<p>把 F1-F12 改成标准功能键：选择<code>System Preferences</code> &gt; <code>Keyboard</code>，在<code>Keyboard</code>标签页中选中<code>Use all F1, F2, etc. keys as standard function keys</code>。</p>
<h3 id="全键盘控制"><a href="#全键盘控制" class="headerlink" title="全键盘控制"></a>全键盘控制</h3><p>当你在 Sublime Text 里关闭文件时，可能会遇到这样的对话框：</p>
<p><img src="/2016/01/22/Mac 设置指南/dialog-box-without-all-controls.png" alt="dialog-box-without-all-controls w500"></p>
<p>注意这个<code>Save</code>按钮跟其他两个按钮不太一样，它的底色是蓝的。这种按钮被称为默认按钮，除了用鼠标点击触发外，还可以通过回车键触发。</p>
<p>那么问题来了，如果你不想保存，想点击<code>Don&#39;t Save</code>，是不是只能用鼠标点击了呢？</p>
<p>并不是这样：选择<code>System Preferences</code> &gt; <code>Keyboard</code>，在<code>Shortcuts</code>标签页中选择<code>All controls</code>；或者使用快捷键<code>⌃F7</code>。之后这个对话框会变成这样：</p>
<p><img src="/2016/01/22/Mac 设置指南/dialog-box-with-all-controls.png" alt="dialog-box-with-all-controls w500"></p>
<p>这个<code>Don&#39;t Save</code>按钮有了一圈蓝边，这个意味着你可以通过空格键触发。不仅如此，你还可以用<code>Tab</code>键把蓝边转移到其他按钮，来实现全键盘控制。</p>
<p>除了<code>All controls</code>这个方法，你还可以用<code>⌘⌫</code>来选择<code>Don&#39;t Save</code>。<code>⌘⌫</code>的作用是在包含“删除”或“不存储”按钮的对话框中选择“删除”或“不存储”。</p>
<p>除了上述两个办法之外，居然还有个方法！就是按<code>⌘D</code>！据说是因为按<code>⌘+按钮的大写首字母</code>可以触发该按钮。可是！我按了<code>⌘C</code>和<code>⌘S</code>想取消和保存都没用！但是<code>⌘D</code>真的有用！如果仅仅是这也就算了，可是我又手贱试了下 TextEdit，在关闭未保存的文件时弹出的对话框上有三个按钮<code>Delete</code>、<code>Cancel</code>和<code>Save</code>。然而<code>⌘D</code>和<code>⌘C</code>都没用，但是！<code>⌘S</code>可以保存！我完全不能理解！我整个人几乎都是崩溃的，只好以咆哮体写下这段文字。如果谁能解释请务必告诉我，必有重谢！</p>
<p><code>⌘C</code>不能用应该是因为它绑定到了复制功能；而<code>⌘D</code>不能用因为它的作用是从“打开”对话框或“存储”对话框中选择“桌面”文件夹。</p>
<p>在这个对话框上，你可以用<code>Esc</code>来执行<code>Cancel</code>操作。</p>
<h3 id="Spotlight-快捷键"><a href="#Spotlight-快捷键" class="headerlink" title="Spotlight 快捷键"></a>Spotlight 快捷键</h3><p>中文版 OS X 的 Spotlight 的快捷键是<code>⌃Space</code>。这个快捷键有一些问题：</p>
<ul>
<li>JetBrains 的 IDE，比如 IntelliJ IDEA、WebStorm 等都使用<code>⌃Space</code>作为自动完成这个最常用功能的快捷键。我不建议更改 IDE 的快捷键，而建议更改 Spotlight 的快捷键。</li>
<li>对于没有添加中文输入法的 Mac 来说，Spotlight 的快捷键是<code>⌘Space</code>。英语国家的人都是这样的。所以我建议把 Spotlight 的快捷键设置为<code>⌘Space</code>，跟他们一致。</li>
</ul>
<h3 id="输入法快捷键"><a href="#输入法快捷键" class="headerlink" title="输入法快捷键"></a>输入法快捷键</h3><p>一般来说切换输入法的快捷键是<code>⌘Space</code>。由于我建议把 Spotlight 的快捷键设置为<code>⌘Space</code>，所以我建议把切换输入法的快捷键设置为<code>⌥Space</code>。</p>
<h3 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h3><p>让双手尽量多的键盘和快捷键，少使用鼠标和触摸板，可以大大提高效率。</p>
<ul>
<li><p><a href="https://support.apple.com/kb/HT201236" target="_blank" rel="external">Mac keyboard shortcts</a></p>
<p>苹果官方文档。当你在写代码，怎么通过快捷键让光标转移到行首、行尾、向上翻页或者将光标移左移一个词？都在这篇文档里。</p>
</li>
<li><p><a href="https://support.apple.com/kb/HT204434" target="_blank" rel="external">Mac keyboard shortcuts for accessibility features</a></p>
<p>苹果官方文档。回车触发蓝底按钮，空格触发蓝边按钮，都出自这里。</p>
</li>
</ul>
<h3 id="设置-Trackpad-轻点来点按"><a href="#设置-Trackpad-轻点来点按" class="headerlink" title="设置 Trackpad 轻点来点按"></a>设置 Trackpad 轻点来点按</h3><p>默认情况下按下触摸板才是点按（click）。我喜欢设置成用轻点作为点按：</p>
<p>选择<code>System Preferences</code> &gt; <code>Trackpad</code>，在<code>Point &amp; Click</code>标签页中选中<code>Tap to click</code>。</p>
<h3 id="语音"><a href="#语音" class="headerlink" title="语音"></a>语音</h3><p>OS X 自带了语音功能，可以用<code>say</code>命令让 Mac 开口说话：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say hello</div></pre></td></tr></table></figure>
<p>可以和<code>&amp;&amp;</code>或者<code>;</code>配合使用来提示你某任务已经完成：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew update &amp;&amp; brew upgrade &amp;&amp; brew cleanup ; say mission complete</div></pre></td></tr></table></figure>
<p>通过命令行来听取发音还是有点麻烦。其实我们几乎可以在任何地方选中单词，然后使用快捷键<code>⌥+ESC</code>发音。仅仅需要这样设置一下：选择<code>System Preferences</code> &gt; <code>Dictation &amp; Speech</code>，在<code>Text to Speech</code>标签页中选中<code>Speak selected text when the key is pressed</code>。</p>
<h3 id="词典"><a href="#词典" class="headerlink" title="词典"></a>词典</h3><p>OS X 自带了词典（Dictionary）。你几乎可以在任何应用中通过三指轻拍触摸板来现实对应单词的释义。</p>
<p>也可以打开 Dictionary 应用来查找单词。</p>
<p>可以在 Dictionary 应用中添加英汉汉英词典。</p>
<h3 id="Dock-Position"><a href="#Dock-Position" class="headerlink" title="Dock Position"></a>Dock Position</h3><p>默认 Dock 在屏幕下方。我们的屏幕一般都是 16:10，Dock 在屏幕下方的话会占据本来就不大的垂直空间。建议把 Dock 放到左边或者右边。</p>
<h3 id="更改-Caps-Lock-键为-Control-键"><a href="#更改-Caps-Lock-键为-Control-键" class="headerlink" title="更改 Caps Lock 键为 Control 键"></a>更改 Caps Lock 键为 Control 键</h3><p>我经常用到<code>Control</code>键，但这个键在键盘的左下角，很难按到。同时我发现我很少使用<code>Caps Lock</code>键，我一般会用<code>Shift</code>键加字母来输入大写字母，或者先输入小写再（通过快捷键）转换成大写。</p>
<p>基于以上原因，我把<code>Caps Lock</code>键的功能改成了<code>Control</code>键。很多同事也都这么做的，可能是受到 <a href="https://en.wikipedia.org/wiki/Happy_Hacking_Keyboard" target="_blank" rel="external">HHKB</a> 的影响。</p>
<p>设置方法：选择<code>System Preferences</code> &gt; <code>Keyboard</code>，在<code>Keyboard</code>标签页中点击<code>Modifier Keys...</code>按钮，在弹出的窗口中，把<code>Caps Lock (⇪) Key:</code>对应的选项改成<code>⌃ Control</code>。</p>
<h3 id="Remove-all-Dock-icons-OCD"><a href="#Remove-all-Dock-icons-OCD" class="headerlink" title="Remove all Dock icons[OCD]"></a>Remove all Dock icons[OCD]</h3><p>本条目对于强迫症适用。</p>
<p>默认情况下 Dock 被一堆系统自带的应用占据着，而其中大部分我都很少使用，当我打开几个常用应用后，Dock 上会有很多图标，每个图标都会被挤得很小。所以我会把所有 Dock 上固定的图标都删掉，这样一来 Dock 上只有我打开的应用。</p>
<p>PS：Finder 图标是删不掉的。</p>
<p>除了一个一个删除图标，也可以通过这个命令来隐藏所有的固定图标：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.dock static-only -boolean <span class="literal">true</span>; killall Dock</div></pre></td></tr></table></figure>
<p>恢复也非常简单：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults delete com.apple.dock static-only; killall Dock</div></pre></td></tr></table></figure>
<p>PS：使用这个方法的话，Dock 上的<code>Downloads</code>也会被隐藏掉。</p>
<h3 id="重置-Launchpad-上图标位置-OCD"><a href="#重置-Launchpad-上图标位置-OCD" class="headerlink" title="重置 Launchpad 上图标位置[OCD]"></a>重置 Launchpad 上图标位置[OCD]</h3><p>本条目对于强迫症适用。</p>
<p>新的应用被安装后，经常会跑到 Launchpad 的第一屏，所以它们的位置跟安装的顺序有关系，而我更希望它们可以按照某种更加稳定的顺序排列，比如按照系统默认的顺序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.dock ResetLaunchPad -bool <span class="literal">true</span>; killall Dock</div></pre></td></tr></table></figure>
<p>在默认顺序中，Launchpad 第一屏只有 Apple 自家应用。</p>
<h3 id="创建大小写敏感的工作区"><a href="#创建大小写敏感的工作区" class="headerlink" title="创建大小写敏感的工作区"></a>创建大小写敏感的工作区</h3><p>在多人合作的项目开发时，因为 Mac 文件系统默认是大小写不敏感的，所以经常会出现一些诡异的问题。创建一个大小写敏感的工作区（workspace）来解决避免这些问题：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hdiutil create -type SPARSE -fs <span class="string">'Case-sensitive Journaled HFS+'</span> -size 100g -volname workspace ~/Documents/workspace.dmg.sparseimage</div></pre></td></tr></table></figure>
<p>可以通过三种方式挂载镜像：</p>
<ol>
<li>直接双击打开 <code>~/Documents/workspace.dmg.sparseimage</code></li>
<li><code>open ~/Documents/workspace.dmg.sparseimage</code></li>
<li><code>hdiutil attach ~/Documents/workspace.dmg.sparseimage</code></li>
</ol>
<h3 id="Keychain-Access"><a href="#Keychain-Access" class="headerlink" title="Keychain Access"></a>Keychain Access</h3><p>钥匙串访问（Keychain Access）是一个 OS X 应用程序，对我来说它最大的功能就是查看已经保存的各种账号和密码，包括 Wi-Fi 密码。</p>
<h2 id="2-常用工具"><a href="#2-常用工具" class="headerlink" title="2. 常用工具"></a>2. 常用工具</h2><p>本节介绍一些常用的，跟开发没有直接关系的第三方应用及其设置。</p>
<h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a><a href="http://brew.sh" target="_blank" rel="external">Homebrew</a></h3><p>包管理工具，官方称之为<code>The missing package manager for OS X</code>。</p>
<p>安装步骤见官网。</p>
<p>有了 brew 以后，要下载工具，比如 MySQL、Gradle、Maven、Node.js 等工具，就不需要去网上下载了，只要一行命令就能搞定：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install mysql gradle maven node</div></pre></td></tr></table></figure>
<p>PS：安装 brew 的时候会自动下载和安装 Apple 的 Command Line Tools。</p>
<p>brew 的替代品有 <a href="https://www.macports.org/" target="_blank" rel="external">MacPorts</a>，现在基本没人用它。</p>
<h3 id="Homebrew-Cask"><a href="#Homebrew-Cask" class="headerlink" title="Homebrew Cask"></a><a href="http://caskroom.io" target="_blank" rel="external">Homebrew Cask</a></h3><p>brew-cask 允许你使用命令行安装 OS X 应用。比如你可以这样安装 Chrome：<code>brew cask install google-chrome</code>。还有 Evernote、Skype、Sublime Text、VirtualBox 等都可以用 brew-cask 安装。</p>
<p>brew-cask 是社区驱动的，如果你发现 brew-cask 上的应用不是最新版本，或者缺少你某个应用，你可以自己提交 pull request。</p>
<p>安装步骤见官网。</p>
<p>应用也可以通过 App Store 安装，而且有些应用只能通过 App Store 安装，比如 Xcode 等一些 Apple 的应用。App Store 没有对应的命令行工具，还需要 Apple ID。倒是更新起来很方便。</p>
<p>几乎所有常用的应用都可以通过 brew-cask 安装，而且是从应用的官网上下载，所以你要安装新的应用时，建议用 brew-cask 安装。如果你不知道应用在 brew-cask 中的 ID，可以先用<code>brew cask search</code>命令搜索。</p>
<h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a><a href="https://www.iterm2.com/" target="_blank" rel="external">iTerm2</a></h3><p>iTerm2 是最常用的终端应用，是 Terminal 应用的替代品。提供了诸如<code>Split Panes</code>等<a href="https://www.iterm2.com/features.html" target="_blank" rel="external">一群实用特性</a>。它默认的黑色背景让我毫不犹豫的抛弃了 Terminal。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew cask install iterm2</div></pre></td></tr></table></figure>
<p>感谢 brew-cask，我们可以通过命令行自动安装 iTerm2 了。</p>
<p>在终端里，除了可以用<code>⌃E</code>等快捷键（详见<a href="#其他快捷键">其他快捷键</a>）之外，还可以使用<code>⌥B</code>、<code>⌥F</code>等快捷键（具体可以参考<a href="http://ss64.com/bash/syntax-keyboard.html" target="_blank" rel="external">这里</a>）。前提是这样设置一下：</p>
<p>选择<code>Iterm</code>菜单 &gt; <code>Preferences</code> &gt; <code>Profiles</code>，选择你在使用的 Profile（默认是<code>Default</code>），在<code>Keys</code>标签页中把<code>Left option (⌥) key acts as</code>和<code>Right option (⌥) key acts as</code>都设置成<code>+ESC</code>。</p>
<p>在打开新的窗口/标签页的时候，默认情况下新窗口总是 HOME 目录，还需要我每次敲命令才能进入工作目录。如果想要这个新窗口在打开的时候就自动进入工作目录，需要如下设置：</p>
<p>选择<code>Iterm</code>菜单 &gt; <code>Preferences</code> &gt; <code>Profiles</code>，选择你在使用的 Profile（默认是Default），在<code>General</code>标签页中的<code>Working Directory</code>部分中选择<code>Reuse previous seesion&#39;s directory</code>。</p>
<p>至此，Terminal 应用已经出色的完成了其历史使命。后面命令行就交给 iTerm2 啦。</p>
<p>在 iTerm2 中双击会自动选中对应的词，三击会选中对应的整行。选中的内容会自动进入剪贴板，不需要再按<code>⌘C</code>复制。</p>
<h3 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh My Zsh"></a><a href="http://ohmyz.sh" target="_blank" rel="external">Oh My Zsh</a></h3><p>默认的 Bash 是黑白的，没有色彩。而 Oh My Zsh 可以带你进入彩色时代。Oh My Zsh 同时提供一套插件和工具，可以简化命令行操作。后面我们会看到很多介绍，你会看到我爱死这家伙了。</p>
<p>安装方法见官网。</p>
<p>目前我使用的插件有：<code>git z sublime history rbenv bundler rake</code></p>
<p>Oh My Zsh 使用了 Z shell（zsh），一个和 Bash 相似的 Shell，而非 Bash。</p>
<p>在 Z shell 中，<code>~/.zshrc</code>是最重要的配置文件。Oh My Zsh 在安装的时候会把当前环境的<code>$PATH</code>写入<code>~/.zshrc</code>中。这并不是我期望的行为，因为使用了 brew，我们基本不再需要去定制<code>$PATH</code>，而 Oh My Zsh 提供的默认<code>$PATH</code>值<code>$HOME/bin:/usr/local/bin:$PATH</code>是非常合适的一个值，它把<code>$HOME/bin</code>加入了<code>$PATH</code>，可以让我们把自己用的脚本放到<code>$HOME/bin</code>下。</p>
<p>所以建议把<code>~/.zshrc</code>重置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</div></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://github.com/robbyrussell/oh-my-zsh/commit/551abfcbb48a0c001eadef80abc3276af4e9ad26" target="_blank" rel="external">2016年6月17号的一次提交</a>后，<code>zshrc.zsh-template</code>就不再修改<code>$PATH</code>了。请找到<code># export PATH=$HOME/bin:/usr/local/bin:$PATH</code>这一行，把前面的<code>#</code>去掉。</p>
</blockquote>
<p>Oh My Zsh 还有很多<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview" target="_blank" rel="external">有价值的插件</a>。</p>
<p>替代品有 <a href="https://github.com/oh-my-fish/oh-my-fish" target="_blank" rel="external">Oh My Fish</a>。基于 <a href="http://fishshell.com/" target="_blank" rel="external">Fishshell</a> 。</p>
<h3 id="Stow"><a href="#Stow" class="headerlink" title="Stow"></a><a href="http://www.gnu.org/software/stow/" target="_blank" rel="external">Stow</a></h3><p>GNU stow 是管理符号链接（symlink）的一个小公举。主要用于 symlink 你的 <a href="http://dotfiles.github.io/" target="_blank" rel="external">dotfiles</a> 如 emacs，git，fish/zsh 的配置文件。安装只需要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install stow</div></pre></td></tr></table></figure>
<p>安装了 stow 之后，我们可以开始 symlink 一些 dotfiles 了。完整使用 stow 和 dotfiles 的流程可以参考 <a href="https://github.com/jcouyang/dotfiles" target="_blank" rel="external">https://github.com/jcouyang/dotfiles</a></p>
<p>当你的 dotfiles 都妥妥的 symlink 到 <code>~/dotfiles</code> 后，push 到 github 上就再也不怕换电脑了。</p>
<h3 id="Git-常用别名"><a href="#Git-常用别名" class="headerlink" title="Git 常用别名"></a>Git 常用别名</h3><p>几乎每个人都会使用一些方法比如 Git 别名来提高效率，几乎所有人都会把使用<code>git st</code>来代替<code>git status</code>。然而这需要手动设置，每个人也都不完全一样。</p>
<p>Oh My Zsh 提供了一套系统别名（alias），来达到相同的功能。比如<code>gst</code>作为<code>git status</code>的别名。而且 Git 插件是 Oh My Zsh 默认启用的，相当于你使用了 Oh My Zsh，你就拥有了一套高效率的别名，而且还是全球通用的。是不是棒棒哒？下面是一些我常用的别名：</p>
<table>
<thead>
<tr>
<th>Alias</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>gapa</td>
<td><code>git add --patch</code></td>
</tr>
<tr>
<td>gc!</td>
<td><code>git commit -v --amend</code></td>
</tr>
<tr>
<td>gcl</td>
<td><code>git clone --recursive</code></td>
</tr>
<tr>
<td>gclean</td>
<td><code>git reset --hard &amp;&amp; git clean -dfx</code></td>
</tr>
<tr>
<td>gcm</td>
<td><code>git checkout master</code></td>
</tr>
<tr>
<td>gcmsg</td>
<td><code>git commit -m</code></td>
</tr>
<tr>
<td>gco</td>
<td><code>git checkout</code></td>
</tr>
<tr>
<td>gd</td>
<td><code>git diff</code></td>
</tr>
<tr>
<td>gdca</td>
<td><code>git diff --cached</code></td>
</tr>
<tr>
<td>glola</td>
<td><code>git log --graph --pretty = format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --all</code></td>
</tr>
<tr>
<td>gp</td>
<td><code>git push</code></td>
</tr>
<tr>
<td>grbc</td>
<td><code>git rebase --continue</code></td>
</tr>
<tr>
<td>gst</td>
<td><code>git status</code></td>
</tr>
<tr>
<td>gup</td>
<td><code>git pull --rebase</code></td>
</tr>
<tr>
<td>gwip</td>
<td><code>git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit -m &quot;--wip--&quot;</code></td>
</tr>
</tbody>
</table>
<p>完整列表请参考：<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git" target="_blank" rel="external">https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git</a></p>
<h3 id="Scroll-Reverser"><a href="#Scroll-Reverser" class="headerlink" title="Scroll Reverser"></a>Scroll Reverser</h3><p>当你在浏览一个很长的网页时，你看完了当前显示的内容，想要看后续的内容，你可以在 Trackpad 上双指上滑，或者鼠标滚轮向上滚动。这是被称作“自然”的滚动方向。</p>
<p>然而在 Windows 里鼠标滚动的行为是相反的：鼠标滚轮向下滚动才会让浏览器显示后续的内容，向上滚动会达到页面的顶部。你可以在 OS X 的系统偏好设置里修改（选择<code>System Preferences</code> &gt; <code>Trackpad</code>，在<code>Scroll &amp; Zoom</code>标签页中不选中<code>Scroll direction: natural</code>），但是这样会同时改变鼠标滚轮的方向和 Trackpad 的方向。</p>
<p>要想只改变鼠标滚轮的方向，而保持 Trackpad 依旧是“自然”的，我们需要 Scroll Reverser：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew cask install scroll-reverser</div></pre></td></tr></table></figure>
<p>PS：这货会让三指点击失效</p>
<h3 id="ShiftIt"><a href="#ShiftIt" class="headerlink" title="ShiftIt"></a>ShiftIt</h3><p>原生 OS X 下只能手动调整窗口大小，所以我们需要窗口管理工具。我用过很多窗口管理工具，可惜大部分工具都存在快捷键冲突的问题（对我来说主要是 IntelliJ IDEA）。ShiftIt 是少见的没有冲突的窗口管理工具：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew cask install shiftit</div></pre></td></tr></table></figure>
<p>PS：ShiftIt的旧版本需要安装 X11，最新版本已经修正了这个问题。</p>
<p>替代者有 SizeUp，主要快捷键和 ShiftIt 相同。</p>
<p>当然如果喜欢 hacking，<a href="https://github.com/jigish/slate" target="_blank" rel="external">Slate</a>  是个不错的 hackable 的窗口管理工具。配置可以参照 <a href="http://thume.ca/howto/2012/11/19/using-slate/" target="_blank" rel="external">http://thume.ca/howto/2012/11/19/using-slate/</a></p>
<h3 id="Sublime-Text-2"><a href="#Sublime-Text-2" class="headerlink" title="Sublime Text 2"></a>Sublime Text 2</h3><p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew cask install sublime-text</div></pre></td></tr></table></figure>
<p>在命令行中指定使用 Sublime Text 打开某文件，是一个非常常用的功能，一般我们会按照 <a href="https://www.sublimetext.com/docs/2/osx_command_line.html" target="_blank" rel="external">OS X Command Line</a> 中所说执行 <code>ln -s &quot;/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl&quot; ~/bin/subl</code> 来增加<code>subl</code>链接。但是如果你用 brew-cask 安装的话，恭喜你，你不需要运行这个命令，因为 brew-cask 自动帮你做了这件事情。而且你卸载 Sublime Text 的时候 brew-cask 会自动删掉这个链接。</p>
<p>同时 Oh My Zsh 也提供了 Sublime Text 插件，叫做<code>sublime</code>。参考：<a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/sublime" target="_blank" rel="external">https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/sublime</a>，这个插件和通过 brew-cask 安装的 Sublime Text 完美兼容。</p>
<p>替代品有 Atom、TextMate、Sublime Text 3 等，跟 Sublime Text 2 一样，用 brew-cask 安装的话命令行工具会被自动加入<code>$PATH</code>。</p>
<h3 id="MacDown"><a href="#MacDown" class="headerlink" title="MacDown"></a>MacDown</h3><p>MacDown 是 Markdown 编辑器。由于 Mou 一直不支持代码高亮，我就转向了 MacDown。完美支持 <a href="https://help.github.com/articles/github-flavored-markdown/" target="_blank" rel="external">GFM</a>。</p>
<p>我特别喜欢 <a href="https://daringfireball.net/projects/markdown/" target="_blank" rel="external">Markdown</a>，我用 Makdown 来写文章（包括本文），写幻灯片（<a href="https://github.com/hakimel/reveal.js/" target="_blank" rel="external">reveal.js</a>）。Markdown 可以让我专注于内容本身，而无需花精力在排版和样式上。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew cask install macdown</div></pre></td></tr></table></figure>
<h3 id="z"><a href="#z" class="headerlink" title="z"></a>z</h3><p>在打开终端后，你是怎么进入项目的工作目录？是<code>cd xxx</code>，<code>⌃R</code>还是用别名？</p>
<p><a href="https://github.com/rupa/z" target="_blank" rel="external">z</a> 工具可以帮你快速进入目录。比如在我的 Mac 上运行<code>z cask</code>就会进入<code>/usr/local/Library/Taps/caskroom/homebrew-cask/Casks</code>目录。</p>
<p>这货的安装非常方便，甚至都不需要下载任何东西，因为它已经整合在了 Oh My Zsh 中。编辑<code>~/.zshrc</code>文件，在<code>plugins=(git)</code>这行中加上<code>z</code>变成<code>plugins=(git z)</code>，然后运行<code>source ~/.zshrc</code>重新加载配置文件，就可以使用 z 了。</p>
<p>替代品有 autojump。autojump 需要使用 brew 安装。</p>
<h3 id="Vimium"><a href="#Vimium" class="headerlink" title="Vimium"></a><a href="https://vimium.github.io/" target="_blank" rel="external">Vimium</a></h3><p>Vimium 是一个 Google Chrome 扩展，让你可以纯键盘操作 Chrome，把你的 Chrome 变成“黑客的浏览器”。</p>
<p>安装方法请参考官方网站。</p>
<p>其他浏览器也有类似的工具，比如 FireFox 的 <a href="https://github.com/mooz/keysnail" target="_blank" rel="external">KeySnail</a>。</p>
<h3 id="LastPass"><a href="#LastPass" class="headerlink" title="LastPass"></a><a href="https://lastpass.com" target="_blank" rel="external">LastPass</a></h3><p>LastPass 是管理密码的工具，支持二次验证，提供所有浏览器插件以及 Mac 桌面版本。</p>
<p>最重要的是，它提供 <strong>命令行</strong> 的版本，可以直接通过 brew 安装</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install lastpass-cli --with-pinentry</div></pre></td></tr></table></figure>
<p>之后，只需要登陆：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lpass login you@email.com</div></pre></td></tr></table></figure>
<p>就可以拷贝密码或者集成到其他命令中了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lpass show --password gmail.com -c</div></pre></td></tr></table></figure>
<h3 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a><a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">SourceTree</a></h3><p>SourceTree 是 Atlassian 公司出品的一款优秀的 Git 图形化客户端。如果你发现命令行无法满足你的要求，可以试试 SourceTree。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew cask install sourcetree</div></pre></td></tr></table></figure>
<p>用 brew-cask 安装会自动增加命令行工具<code>stree</code>到<code>$PATH</code>里。在命令行中输入<code>stree</code>可以快速用 SourceTree 打开当前 Git 仓库。详细用法请参见<code>stree --help</code>。</p>
<h3 id="CheatSheet"><a href="#CheatSheet" class="headerlink" title="CheatSheet"></a><a href="http://www.mediaatelier.com/CheatSheet/" target="_blank" rel="external">CheatSheet</a></h3><p>CheatSheet 能够显示当前程序的快捷键列表，默认的快捷键是长按<code>⌘</code>。</p>
<p><img src="http://www.mediaatelier.com/CheatSheet/imgs/main.png" alt="CheatSheet"></p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew cask install cheatsheet</div></pre></td></tr></table></figure>
<h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a><a href="https://www.alfredapp.com" target="_blank" rel="external">Alfred</a></h3><p>Mac 用户不用鼠标键盘的必备神器，配合大量 Workflows，习惯之后可以大大减少操作时间。</p>
<p>上手简单，调教成本在后期自定义 Workflows，不过有大量雷锋使用者提供的现成扩展，访问<a href="http://www.alfredworkflow.com/" target="_blank" rel="external">这里</a>挑选喜欢的，并可以极其简单地根据自己的需要修改。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew cask install alfred</div></pre></td></tr></table></figure>
<h2 id="3-开发工具"><a href="#3-开发工具" class="headerlink" title="3. 开发工具"></a>3. 开发工具</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>现在 OS X 都不会自带 JDK 了，所以进行 Java 开发的话，需要下载 JDK。在 brew-cask 之前，我们需要从 <a href="https://developer.apple.com/downloads/" target="_blank" rel="external">https://developer.apple.com/downloads/</a> 或者 Oracle 网站上下载。还有更麻烦的－－卸载 JDK 和升级 JDK。</p>
<p>JDK 安装文件是 pkg 格式，卸载和<code>.app</code>不一样，且没有自动卸载方式。</p>
<p>而 brew-cask 提供了自动安装和卸载功能，能够自动从官网上下载并安装 JDK 8。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew cask install java</div></pre></td></tr></table></figure>
<p>如果你需要安装 JDK 7 或者 JDK 6，可以使用<code>homebrew-cask-versions</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew tap caskroom/versions</div><div class="line">brew cask install java6</div></pre></td></tr></table></figure>
<p>在 OS X 上，你可以同时安装多个版本的 JDK。你可以通过命令<code>/usr/libexec/java_home -V</code>来查看安装了哪几个 JDK。</p>
<p>那问题来了，当你运行<code>java</code>或者 Java 程序时使用的是哪个 JDK 呢？在 OS X 下，<code>java</code>也就是<code>/usr/bin/java</code>在默认情况下指向的是已经安装的最新版本。但是你可以设置环境变量<code>JAVA_HOME</code>来更改其指向：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ java -version</div><div class="line">java version <span class="string">"1.8.0_60"</span></div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_60-b27)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)</div><div class="line">$ JAVA_HOME=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home java -version</div><div class="line">java version <span class="string">"1.6.0_65"</span></div><div class="line">Java(TM) SE Runtime Environment (build 1.6.0_65-b14-466.1-11M4716)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-466.1, mixed mode)</div></pre></td></tr></table></figure>
<p>其中<code>JAVA_HOME=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home</code>可以用<code>JAVA_HOME=`/usr/libexec/java_home -v 1.6` </code>这种更加通用的方式代替。</p>
<h3 id="jEnv"><a href="#jEnv" class="headerlink" title="jEnv"></a><a href="https://github.com/gcuisinier/jenv" target="_blank" rel="external">jEnv</a></h3><p>也可以使用 jEnv 来管理不同版本的 JDK，这个工具跟 <a href="#rbenv">rbenv</a> 类似，通过当前目录下的<code>.java-version</code>来决定使用哪个 JDK。jEnv 也可以用 brew 安装。不过要使用 jEnv 要有几个问题：</p>
<ul>
<li><p>需要手动把<code>eval &quot;$(jenv init -)&quot;</code>加入 profile，没有 Oh My Zsh 插件。这点是我非常反感的。</p>
<p>可以把<code>eval &quot;$(jenv init -)&quot;</code>加入<code>~/.zlogin</code>，这样可以避免修改<code>~/.zshrc</code>。</p>
</li>
<li>需要手动添加 JDK，不会自动采集系统 JDK。跟 Ruby 不同，OS X 已经提供<code>/usr/libexec/java_home</code>工具来管理安装的 JDK。</li>
<li>需要 <code>jenv rehash</code>。这个是跟 rbenv 学的。</li>
</ul>
<p>所以我建议不要使用 jEnv。</p>
<h3 id="民间使用的-Java-版本切换方法"><a href="#民间使用的-Java-版本切换方法" class="headerlink" title="民间使用的 Java 版本切换方法"></a>民间使用的 Java 版本切换方法</h3><p>添加以下脚本到当前 shell 配置文件中：<code>~/.zprofile</code>或者<code>~/.bash_profile</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">setjdk</span></span>() &#123;</div><div class="line">    <span class="built_in">export</span> JAVA_HOME=`/usr/libexec/java_home -v <span class="variable">$@</span>`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样我们就可以通过输入一条命令进行版本切换了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setjdk 1.8</div></pre></td></tr></table></figure>
<h3 id="Java-OCD"><a href="#Java-OCD" class="headerlink" title="Java[OCD]"></a>Java[OCD]</h3><p>作为一个强迫症患者，每当我看到 Java 的错误写法就想纠正过来。</p>
<p>当指编程语言时，Java 的正确写法是首字母大写，其余小写。其他写法比如<code>JAVA</code>、<code>java</code>都是不对的。</p>
<p>在其他一些地方会使用小写的<code>java</code>：</p>
<ul>
<li><code>java</code>命令</li>
<li>原文件<code>Main.java</code></li>
<li>包名<code>java.lang</code></li>
</ul>
<p>只有在全大写的标题里使用<code>JAVA</code>或者环境变量<code>JAVA_HOME</code>。</p>
<h3 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h3><p>Java 开发必备工具 IntelliJ IDEA。可以安装 Ultimate Edition：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew cask install intellij-idea</div></pre></td></tr></table></figure>
<p>也可以安装开源免费的 Community Edition：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew cask install intellij-idea-ce</div></pre></td></tr></table></figure>
<p>IntelliJ IDEA 有几套内建的快捷键方案（Keymap）。其中适用于 OS X 的有<code>Mac OS X</code>和<code>Mac OS X 10.5+</code>两种。区别是:</p>
<ul>
<li><code>Mac OS X</code>方案和其他平台上的快捷键类似，</li>
<li>而<code>Mac OS X 10.5+</code>更加符合 OS X 常用的快捷键。</li>
</ul>
<p>一个团队使用不同的快捷键会严重影响效率。可以用<code>View | Quick Switch Scheme</code>（<code>⌃ Back Quote</code>）快速切换 Keymap。</p>
<p>如果可以选择的话，我建议使用<code>Mac OS X</code>方案。因为我经常遇到使用 Windows 的客户，而 Windows 平台上的快捷键和<code>Mac OS X</code>方案类似。</p>
<p>可以从 IDEA 的<code>Help &gt; Default Keymap Reference</code>打开快捷键的参考手册。不过从这里打开的是<code>Mac OS X 10.5+</code>方案的，而<code>Mac OS X</code>方案的可以从这里找到：<a href="http://www.basrikahveci.com/static/ij_keymap_mac.pdf" target="_blank" rel="external">http://www.basrikahveci.com/static/ij_keymap_mac.pdf</a>。</p>
<h3 id="rbenv"><a href="#rbenv" class="headerlink" title="rbenv"></a><a href="https://github.com/sstephenson/rbenv" target="_blank" rel="external">rbenv</a></h3><p>人人都需要一个 Ruby 版本管理工具。rbenv 就是这样一个轻量级工具，它可以通过 brew 安装。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install rbenv ruby-build</div></pre></td></tr></table></figure>
<p>然后在<code>~/.zshrc</code>中加上<code>rbenv</code>插件。否则你需要手动添加<code>eval &quot;$(rbenv init -)&quot;</code>到<code>~/zshrc</code>或者<code>~/.zprofile</code>文件里。</p>
<p>有时候项目会依赖一些奇怪的版本号，比如<code>ruby-2.1.0</code>，这个时候你需要 <a href="https://github.com/tpope/rbenv-aliases" target="_blank" rel="external">rbenv-aliases</a> 帮忙：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install rbenv-aliases</div></pre></td></tr></table></figure>
<p>替代品有 RVM、chruby。因为 RVM 不能通过 brew 安装，并且安装的时候会没有节操的修改一堆文件，所以被我早早的弃用了。chruby 也是一个轻量级工具，而且可以完美的和 Oh My Zsh 集成在一起，我看到有些生产环境在用它。</p>
<h3 id="Ruby-常用别名"><a href="#Ruby-常用别名" class="headerlink" title="Ruby 常用别名"></a>Ruby 常用别名</h3><p>几乎所有 Ruby 开发人员都会把<code>bi</code>作为<code>bundle install</code>的别名。Oh My Zsh 提供<code>builder</code>插件，这个插件提供了一套别名，比如<code>bi</code>、<code>be</code>。同时还能让你在运行一些常用 gem 的时候直接输入<code>rspec</code>，不需要<code>be rspec</code>这样了。具体包括哪些命令请参考<a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/bundler" target="_blank" rel="external">这里</a>。</p>
<p>Z shell 对于<code>[</code>和<code>]</code>符号有特殊的处理，所以在运行<code>rake task[parameter]</code>的时候会报错，你需要改成<code>rake task\[parameter\]</code>或者<code>noglob rake task[parameter]</code>。然而 Oh My Zsh 已经看穿这一切，自带的 rake 插件已经解决了这个问题：<code>brake task[parameter]</code>。</p>
<p>添加插件的时候注意把<code>rake</code>放到<code>bundler</code>后面，例如这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plugins=(git z sublime history rbenv bundler rake)</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://lapwinglabs.com/blog/hacker-guide-to-setting-up-your-mac" target="_blank" rel="external">Hacker’s Guide to Setting up Your Mac</a></li>
<li><a href="https://mattstauffer.co/blog/setting-up-a-new-os-x-development-machine-part-1-core-files-and-custom-shell" target="_blank" rel="external">Setting up a new (OS X) development machine</a></li>
<li><a href="http://www.xialeizhou.com/?p=71" target="_blank" rel="external">高效 MacBook 工作环境配置</a></li>
<li><a href="http://www.zhihu.com/question/20873070" target="_blank" rel="external">程序员如何优雅地使用 Mac？</a></li>
<li><a href="http://sspai.com/33493" target="_blank" rel="external">装点你的 Dock：外观篇</a></li>
</ul>
<h3 id="原文出处"><a href="#原文出处" class="headerlink" title="原文出处"></a><a href="https://github.com/macdao/ocds-guide-to-setting-up-mac/blob/master/README.en.md" target="_blank" rel="external">原文出处</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mac-设置指南&quot;&gt;&lt;a href=&quot;#Mac-设置指南&quot; class=&quot;headerlink&quot; title=&quot;Mac 设置指南&quot;&gt;&lt;/a&gt;Mac 设置指南&lt;/h1&gt;&lt;h2 id=&quot;Table-of-Contents&quot;&gt;&lt;a href=&quot;#Table-of-Con
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>atom 快捷键</title>
    <link href="http://yoursite.com/2015/08/22/atom%20%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2015/08/22/atom 快捷键/</id>
    <published>2015-08-22T12:21:04.000Z</published>
    <updated>2017-03-03T12:24:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="atom-快捷键"><a href="#atom-快捷键" class="headerlink" title="atom 快捷键"></a>atom 快捷键</h1><h2 id="文件切换"><a href="#文件切换" class="headerlink" title="文件切换"></a>文件切换</h2><p><code>ctrl-shift-s</code>  保存所有打开的文件<br><code>cmd-shift-o</code>  打开目录<br><code>cmd-\</code>   显示或隐藏目录树<br><code>ctrl-0</code>   焦点移到目录树<br>目录树下，使用a，m，delete来增加，修改和删除<br><code>cmd-t</code>或<code>cmd-p</code> 查找文件<br><code>cmd-b</code> 在打开的文件之间切换<br><code>cmd-shift-b</code> 只搜索从上次git commit后修改或者新增的文件  </p>
<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>（等价于上下左右）<br><code>ctrl-p</code> 前一行<br><code>ctrl-n</code> 后一行<br><code>ctrl-f</code> 前一个字符<br><code>ctrl-b</code> 后一个字符  </p>
<p><code>alt-B</code>, <code>alt-left</code> 移动到单词开始<br><code>alt-F</code>, <code>alt-right</code> 移动到单词末尾  </p>
<p><code>cmd-right</code>, <code>ctrl-E</code> 移动到一行结束<br><code>cmd-left</code>, <code>ctrl-A</code>  移动到一行开始  </p>
<p><code>cmd-up</code> 移动到文件开始<br><code>cmd-down</code> 移动到文件结束  </p>
<p><code>ctrl-g</code> 移动到指定行 row:column 处</p>
<p><code>cmd-r</code> 在方法之间跳转</p>
<h2 id="目录树操作"><a href="#目录树操作" class="headerlink" title="目录树操作"></a>目录树操作</h2><p><code>cmd-\</code> 或者 <code>cmd-k cmd-b</code> 显示(隐藏)目录树<br><code>ctrl-0</code> 焦点切换到目录树(再按一次或者<code>Esc</code>退出目录树)<br><code>a</code> 添加文件<br><code>d</code> 将当前文件另存为(duplicate)<br><code>i</code> 显示(隐藏)版本控制忽略的文件<br><code>alt-right</code> 和 <code>alt-left</code> 展开(隐藏)所有目录<br><code>ctrl-al-]</code> 和 <code>ctrl-al-[</code> 同上<br><code>ctrl-[</code> 和 <code>ctrl-]</code> 展开(隐藏)当前目录<br><code>ctrl-f</code> 和 <code>ctrl-b</code> 同上<br><code>cmd-k h</code> 或者 <code>cmd-k left</code> 在左半视图中打开文件<br><code>cmd-k j</code> 或者 <code>cmd-k down</code> 在下半视图中打开文件<br><code>cmd-k k</code> 或者 <code>cmd-k up</code> 在上半视图中打开文件<br><code>cmd-k l</code> 或者 <code>cmd-k right</code> 在右半视图中打开文件<br><code>ctrl-shift-C</code> 复制当前文件绝对路径</p>
<h2 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h2><p><code>cmd-F2</code> 在本行增加书签<br><code>F2</code> 跳到当前文件的下一条书签<br><code>shift-F2</code> 跳到当前文件的上一条书签<br><code>ctrl-F2</code> 列出当前工程所有书签  </p>
<h2 id="选取"><a href="#选取" class="headerlink" title="选取"></a>选取</h2><blockquote>
<p>大部分和导航一致，只不过加上shift  </p>
</blockquote>
<p><code>ctrl-shift-P</code>  选取至上一行<br><code>ctrl-shift-N</code>  选取至下一样<br><code>ctrl-shift-B</code>  选取至前一个字符<br><code>ctrl-shift-F</code>  选取至后一个字符<br><code>alt-shift-B</code>, <code>alt-shift-left</code>  选取至字符开始<br><code>alt-shift-F</code>, <code>alt-shift-right</code>  选取至字符结束<br><code>ctrl-shift-E</code>, <code>cmd-shift-right</code>  选取至本行结束<br><code>ctrl-shift-A</code>, <code>cmd-shift-left</code>  选取至本行开始<br><code>cmd-shift-up</code>  选取至文件开始<br><code>cmd-shift-down</code>  选取至文件结尾<br><code>cmd-A</code>  全选<br><code>cmd-L</code>  选取一行，继续按回选取下一行<br><code>ctrl-shift-W</code>  选取当前单词  </p>
<h2 id="编辑和删除文本"><a href="#编辑和删除文本" class="headerlink" title="编辑和删除文本"></a>编辑和删除文本</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><code>ctrl-T</code> 使光标前后字符交换<br><code>cmd-J</code> 将下一行与当前行合并<br><code>ctrl-cmd-up</code>, <code>ctrl-cmd-down</code> 使当前行向上或者向下移动<br><code>cmd-shift-D</code> 复制当前行到下一行<br><code>cmd-K</code>, <code>cmd-U</code> 使当前字符大写<br><code>cmd-K</code>, <code>cmd-L</code> 使当前字符小写<br><code>cmd-shift-P</code> 搜索命令  </p>
<h3 id="删除和剪切"><a href="#删除和剪切" class="headerlink" title="删除和剪切"></a>删除和剪切</h3><p><code>ctrl-shift-K</code> 删除当前行<br><code>cmd-backspace</code> 删除到当前行开始<br><code>cmd-fn-backspace</code> 删除到当前行结束<br><code>ctrl-K</code> 剪切到当前行结束<br><code>alt-backspace</code> 或 <code>alt-H</code> 删除到当前单词开始<br><code>alt-delete</code> 或 <code>alt-D</code> 删除到当前单词结束  </p>
<h3 id="多光标和多处选取"><a href="#多光标和多处选取" class="headerlink" title="多光标和多处选取"></a>多光标和多处选取</h3><p><code>cmd-click</code> 增加新光标<br><code>cmd-shift-L</code> 将多行选取改为多行光标<br><code>ctrl-shift-up</code>, <code>ctrl-shift-down</code> 增加上（下）一行光标<br><code>cmd-D</code> 选取文档中和当前单词相同的下一处<br><code>ctrl-cmd-G</code> 选取文档中所有和当前光标单词相同的位置  </p>
<h3 id="括号跳转"><a href="#括号跳转" class="headerlink" title="括号跳转"></a>括号跳转</h3><p><code>ctrl-m</code> 相应括号之间，html tag之间等跳转<br><code>ctrl-cmd-m</code> 括号(tag)之间文本选取<br><code>alt-cmd-.</code> 关闭当前XML/HTML tag  </p>
<h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><p><code>ctrl-shift-U</code> 调出切换编码选项  </p>
<h2 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h2><p><code>cmd-F</code> 在buffer中查找<br><code>cmd-shift-f</code> 在整个工程中查找  </p>
<h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><p><code>alt-shift-S</code> 查看当前可用代码片段  </p>
<blockquote>
<p>在<code>~/.atom</code>目录下<code>snippets.cson</code>文件中存放了你定制的snippets  </p>
</blockquote>
<p><a href="https://atom.io/docs/v1.0.0/using-atom-snippets" target="_blank" rel="external">定制说明</a>  </p>
<h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p><code>ctrl-space</code> 提示补全信息  </p>
<h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><p><code>alt-cmd-[</code> 折叠<br><code>alt-cmd-]</code> 展开<br><code>alt-cmd-shift-{</code> 折叠全部<br><code>alt-cmd-shift-}</code> 展开全部<br><code>cmd-k cmd-N</code> 指定折叠层级 N为层级数  </p>
<h2 id="文件语法高亮"><a href="#文件语法高亮" class="headerlink" title="文件语法高亮"></a>文件语法高亮</h2><p><code>ctrl-shift-L</code> 选择文本类型  </p>
<h2 id="使用Atom进行写作"><a href="#使用Atom进行写作" class="headerlink" title="使用Atom进行写作"></a>使用Atom进行写作</h2><p><code>ctrl-shift-M</code> Markdown预览<br>可用代码片段</p>
<blockquote>
<p>b, legal, img, l, i, code, t, table</p>
</blockquote>
<h2 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h2><p><code>cmd-alt-Z</code> checkout HEAD 版本<br><code>cmd-shift-B</code> 弹出untracked 和 modified文件列表<br><code>alt-g down</code> <code>alt-g up</code> 在修改处跳转<br><code>alt-G D</code> 弹出diff列表<br><code>alt-G O</code> 在github上打开文件<br><code>alt-G G</code> 在github上打开项目地址<br><code>alt-G B</code> 在github上打开文件blame<br><code>alt-G H</code> 在github上打开文件history<br><code>alt-G I</code> 在github上打开issues<br><code>alt-G R</code> 在github打开分支比较<br><code>alt-G C</code> 拷贝当前文件在gihub上的网址  </p>
<h2 id="推荐一些好用的插件"><a href="#推荐一些好用的插件" class="headerlink" title="推荐一些好用的插件"></a>推荐一些好用的插件</h2><ul>
<li>主题<br><a href="https://atom.io/themes/atom-material-ui" target="_blank" rel="external">atom-material-ui</a> 好看到爆<br><a href="https://atom.io/themes/atom-material-syntax" target="_blank" rel="external">atom-material-syntax</a></li>
<li>美化<br><a href="https://atom.io/packages/atom-beautify" target="_blank" rel="external">atom-beautify</a> 一键代码美化<br><a href="https://atom.io/packages/file-icons" target="_blank" rel="external">file-icons</a> 给文件加上好看的图标<br><a href="https://atom.io/users/atom-minimap" target="_blank" rel="external">atom-minimap</a> 方便美观的缩略滚动图<br><a href="https://atom.io/packages/pretty-json" target="_blank" rel="external">pretty-json</a> json格式化工具<br><a href="https://atom.io/packages/activate-power-mode" target="_blank" rel="external">activate-power-mode</a> 炫酷的打字特效</li>
<li>git<br><a href="https://atom.io/packages/atomatigit" target="_blank" rel="external">atomatigit</a> 可视化git操作<br><a href="https://atom.io/packages/git-time-machine" target="_blank" rel="external">git-time-machine</a> git版本对比工具，可视化选择每一个commit<br><a href="https://atom.io/packages/merge-conflicts" target="_blank" rel="external">merge-conflicts</a> 合并冲突可视化工具</li>
<li>代码提示<br><a href="https://atom.io/packages/emmet" target="_blank" rel="external">emmet</a> 这个不用介绍了吧<br><a href="https://atom.io/packages/atom-ternjs" target="_blank" rel="external">atom-ternjs</a> js代码提示很强大，高度定制化<br><a href="https://atom.io/packages/docblockr" target="_blank" rel="external">docblockr</a> jsdoc 给js添加注释<br><a href="https://atom.io/packages/autoclose-html" target="_blank" rel="external">autoclose-html</a> 闭合html标签<br><a href="https://atom.io/packages/color-picker" target="_blank" rel="external">color-picker</a> 取色器 必备插件<br><a href="https://atom.io/packages/pigments" target="_blank" rel="external">pigments</a> 颜色显示插件 必装<br><a href="https://atom.io/packages/terminal-panel" target="_blank" rel="external">terminal-panel</a> 直接在atom里面写命令了<br><a href="https://atom.io/packages/svg-preview" target="_blank" rel="external">svg-preview</a> svg预览</li>
<li>便捷操作<br><a href="https://atom.io/packages/advanced-open-file" target="_blank" rel="external">advanced-open-file</a> 快速打开、切换文件<br><a href="https://atom.io/packages/project-folder" target="_blank" rel="external">project-folder</a> 快速打开、切换项目<br><a href="https://atom.io/packages/script" target="_blank" rel="external">script</a> 立即执行当前js文件</li>
<li>高亮<br><a href="https://atom.io/packages/language-vue" target="_blank" rel="external">language-vue</a> vue框架代码高亮</li>
<li>终端<br><a href="https://atom.io/packages/platformio-ide-terminal" target="_blank" rel="external">platformio-atom-ide-terminal</a> 终端插件，支持显示、隐藏及多窗口</li>
</ul>
<p>就这些了，欢迎pull更多好用的插件！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;atom-快捷键&quot;&gt;&lt;a href=&quot;#atom-快捷键&quot; class=&quot;headerlink&quot; title=&quot;atom 快捷键&quot;&gt;&lt;/a&gt;atom 快捷键&lt;/h1&gt;&lt;h2 id=&quot;文件切换&quot;&gt;&lt;a href=&quot;#文件切换&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git 命令大全</title>
    <link href="http://yoursite.com/2015/06/11/bash/"/>
    <id>http://yoursite.com/2015/06/11/bash/</id>
    <published>2015-06-11T08:10:04.000Z</published>
    <updated>2017-03-03T12:45:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>##MD5<br>不可逆<br>加盐 + 一个独有的字符串 </p>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>本地 - 服务端  都保存一个 字符串<br>通过这个字符串来解密</p>
<p>加密</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>   每台电脑都一对公钥和私钥, ssh -keygen -t rsa 生成</p>
<pre><code>1. 申请时,服务器电脑发送一个 公钥
2. 本地发送 密码 和 公钥
3. 公钥 只有相对应的电脑 私钥  才能解开
</code></pre><h4 id="免密码登入"><a href="#免密码登入" class="headerlink" title="免密码登入"></a>免密码登入</h4><p> 1.登入 发送本地的rsa_pub<br> 2.远程的rsa_pub 发送到本地<br> 3.本地的rsa 和 远程的rsa_pub  发送到服务器</p>
<h2 id="vi-编辑器"><a href="#vi-编辑器" class="headerlink" title="vi 编辑器"></a>vi 编辑器</h2><p>vi<br>cat 查看<br> mv移动<br> cp拷贝<br>    <img src="/2015/06/11/bash/vi.png" alt="屏幕快照 2017-03-01 上午9.03.10 w400"></p>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>平衡分支 通过develop(开发)</p>
<p>git init<br>git add<br>git commit<br>git rm 删除文件</p>
<p>git –version git测试</p>
<p>.gitignore 文件内 记录 忽略的文件</p>
<p>git add –all<br>git add 文件名   将文件放到暂存区<br>git commit 将当前文件夹的副本保存<br>git commit -m 提交说明 很有必要 每个版本干了什么<br>一般完成一个小单元 (功能) 提交一次<br>git commit -m”wrote a readme file”<br>git staus 状态 </p>
<p>git diff 区别<br>git log 日志 修改日志<br>用git reflog  查看命令历史<br>git reset –hard 版本号前6位 回退到之前的版本<br>$ git reset –hard HEAD^<br>git clone 网址 .  克隆到当前地址 </p>
<p>想直接丢弃工作区的修改时，用命令git checkout – file</p>
<h3 id="先删后加"><a href="#先删后加" class="headerlink" title="先删后加"></a>先删后加</h3><p>git remote rm origin<br>git remote add origin [url]<br>git push origin master 提交到远端</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>git branch 查看当前分支<br>git checkout -b dev 等同于<br>$ git branch dev 创建 分支dev<br>$ git checkout dev 切换分支</p>
<p>git merge dev 将分支dev 合并到master<br>git branch -d dev  删除分支dev</p>
<p>git log –graph</p>
<p>git stash - 临时储存<br>git stash apply  恢复储存<br>git stash list  储存列表<br>git stash pop 恢复并删除</p>
<h3 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h3><p>git push git@gitlab.com:Werther-cool/my-test.git master<br>git push origin dev 将本地dev 推送到远程,若没有就自动创建<br>git push origin branch-name 从本地推送分支<br>git pull 下从远端拉取<br>git checkout -b branch-name origin/branch-name 在本地创建和远程分支对应的分支<br>git branch –set-upstream branch-name origin/branch-name建立本地分支和远程分支的关联</p>
<h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><p>git tag v1.0  默认标签打给最新的commit<br>git log –pretty=oneline –abbrev-commit 显示操作短码<br>git tag v0.9 42a6d4a<br>git tag 查看所有tag<br>git show v0.9 查看详细信息<br>git tag -d v0.9 删除该tag</p>
<h4 id="linux基础命令；"><a href="#linux基础命令；" class="headerlink" title="linux基础命令；"></a>linux基础命令；</h4><p>touch    111.txt 新建文本文件<br>rm 文件   删除文件<br>sudo -s   获取绝对用户权限<br>cd xxx    进入xxx目录<br>ls (-a/-A)   显示当前路径下所有文件(隐藏的)<br>pwd       显示当前绝对路径<br>mkdir  xxx   创建文件夹xxx<br>man xxx     查看xxx命令手册</p>
<h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>//显示隐藏文件<br>defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder<br>//不显示隐藏文件<br>defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder </p>
<h3 id="然后介绍下Git基础命令的含义；"><a href="#然后介绍下Git基础命令的含义；" class="headerlink" title="然后介绍下Git基础命令的含义；"></a>然后介绍下Git基础命令的含义；</h3><p>clone   克隆远程仓库<br>init       初始化仓库<br>remote 连接远程仓库<br>pull      从远程仓库下拉获取新数据<br>push    将本地仓库新增或修改文件上传到远程仓库<br>add     添加文件或者修改文件，commit以及push之前使用<br>log      当前仓库提交过的日志信息<br>status  当前仓库版本状态<br>commit 提交到当前仓库中<br>branch 分支命令，相关增删查操作<br>checkout 使用远程仓库最后一个版本完全覆盖当前仓库内容／选择分支branch<br>diff      对比版本内容<br>merge   合并版本内容</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;加密&quot;&gt;&lt;a href=&quot;#加密&quot; class=&quot;headerlink&quot; title=&quot;加密&quot;&gt;&lt;/a&gt;加密&lt;/h2&gt;&lt;p&gt;##MD5&lt;br&gt;不可逆&lt;br&gt;加盐 + 一个独有的字符串 &lt;/p&gt;
&lt;h2 id=&quot;对称加密&quot;&gt;&lt;a href=
    
    </summary>
    
    
  </entry>
  
</feed>
